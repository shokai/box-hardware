FILE: .\boot.asm
                                        (0001) ; Generated by PSoC Designer 5.0.1127.0
                                        (0002) ;
                                        (0003) ;@Id: boot.tpl#895 @
                                        (0004) ;=============================================================================
                                        (0005) ;  FILENAME:   boot.asm
                                        (0006) ;  Version:    4.18
                                        (0007) ;
                                        (0008) ;  DESCRIPTION:
                                        (0009) ;  M8C Boot Code for CY8C29xxx microcontroller family.
                                        (0010) ;
                                        (0011) ;  Copyright (c) Cypress Semiconductor 2009. All Rights Reserved.
                                        (0012) ;
                                        (0013) ; NOTES:
                                        (0014) ; PSoC Designer's Device Editor uses a template file, BOOT.TPL, located in
                                        (0015) ; the project's root directory to create BOOT.ASM. Any changes made to
                                        (0016) ; BOOT.ASM will be  overwritten every time the project is generated; therefore
                                        (0017) ; changes should be made to BOOT.TPL not BOOT.ASM. Care must be taken when
                                        (0018) ; modifying BOOT.TPL so that replacement strings (such as @PROJECT_NAME)
                                        (0019) ; are not accidentally modified.
                                        (0020) ;
                                        (0021) ;=============================================================================
                                        (0022) 
                                        (0023) include ".\lib\GlobalParams.inc"	;File generated by PSoC Designer (Project dependent)
                                        (0024) include "m8c.inc"			;Part specific file
                                        (0025) include "m8ssc.inc"			;Part specific file
                                        (0026) include "memory.inc"			;File generated by PSoC Designer (Project dependent)
                                        (0027) 
                                        (0028) ;--------------------------------------
                                        (0029) ; Export Declarations
                                        (0030) ;--------------------------------------
                                        (0031) 
                                        (0032) export __Start
                                        (0033) IF	(TOOLCHAIN & HITECH)
                                        (0034) ELSE
                                        (0035) export __bss_start
                                        (0036) export __data_start
                                        (0037) export __idata_start
                                        (0038) export __func_lit_start
                                        (0039) export __text_start
                                        (0040) ENDIF
                                        (0041) export  _bGetPowerSetting
                                        (0042) export   bGetPowerSetting
                                        (0043) 
                                        (0044) 
                                        (0045) ;--------------------------------------
                                        (0046) ; Optimization flags
                                        (0047) ;--------------------------------------
                                        (0048) ;
                                        (0049) ; To change the value of these flags, modify the file boot.tpl, not
                                        (0050) ; boot.asm. See the notes in the banner comment at the beginning of
                                        (0051) ; this file.
                                        (0052) 
                                        (0053) ; Optimization for Assembly language (only) projects and C-language projects
                                        (0054) ; that do not depend on the C compiler to initialize the values of RAM variables.
                                        (0055) ;   Set to 1: Support for C Run-time Environment initialization
                                        (0056) ;   Set to 0: Support for C not included. Faster start up, smaller code space.
                                        (0057) ;
                                        (0058) IF	(TOOLCHAIN & HITECH)
                                        (0059) ; The C compiler will customize the startup code - it's not required here
                                        (0060) 
                                        (0061) C_LANGUAGE_SUPPORT:              equ 0
                                        (0062) ELSE
                                        (0063) C_LANGUAGE_SUPPORT:              equ 1
                                        (0064) ENDIF
                                        (0065) 
                                        (0066) 
                                        (0067) ; The following equate is required for proper operation. Reseting its value
                                        (0068) ; is discouraged.  WAIT_FOR_32K is effective only if the crystal oscillator is
                                        (0069) ; selected.  If the designer chooses to not wait then stabilization of the ECO
                                        (0070) ; and PLL_Lock must take place within user code. See the family data sheet for
                                        (0071) ; the requirements of starting the ECO and PLL lock mode.
                                        (0072) ;
                                        (0073) ;   Set to 1: Wait for XTAL (& PLL if selected) to stabilize before
                                        (0074) ;                invoking main
                                        (0075) ;   Set to 0: Boot code does not wait; clock may not have stabilized by
                                        (0076) ;               the time code in main starts executing.
                                        (0077) ;
                                        (0078) WAIT_FOR_32K:                    equ 1
                                        (0079) 
                                        (0080) 
                                        (0081) ; For historical reasons, by default the boot code uses an lcall instruction
                                        (0082) ; to invoke the user's _main code. If _main executes a return instruction,
                                        (0083) ; boot provides an infinite loop. By changing the following equate from zero
                                        (0084) ; to 1, boot's lcall will be replaced by a ljmp instruction, saving two
                                        (0085) ; bytes on the stack which are otherwise required for the return address. If
                                        (0086) ; this option is enabled, _main must not return. (Beginning with the 4.2
                                        (0087) ; release, the C compiler automatically places an infinite loop at the end
                                        (0088) ; of main, rather than a return instruction.)
                                        (0089) ;
                                        (0090) ENABLE_LJMP_TO_MAIN:             equ 0
                                        (0091) 
                                        (0092) 
                                        (0093) ;-----------------------------------------------------------------------------
                                        (0094) ; Interrupt Vector Table
                                        (0095) ;-----------------------------------------------------------------------------
                                        (0096) ;
                                        (0097) ; Interrupt vector table entries are 4 bytes long.  Each one contains
                                        (0098) ; a jump instruction to an ISR (Interrupt Service Routine), although
                                        (0099) ; very short ISRs could be encoded within the table itself. Normally,
                                        (0100) ; vector jump targets are modified automatically according to the user
                                        (0101) ; modules selected. This occurs when the 'Generate Application' opera-
                                        (0102) ; tion is run causing PSoC Designer to create boot.asm and the other
                                        (0103) ; configuration files. If you need to hard code a vector, update the
                                        (0104) ; file boot.tpl, not boot.asm. See the banner comment at the beginning
                                        (0105) ; of this file.
                                        (0106) ;-----------------------------------------------------------------------------
                                        (0107) 
                                        (0108)     AREA TOP (ROM, ABS, CON)
                                        (0109) 
                                        (0110)     org   0                        ;Reset Interrupt Vector
                                        (0111) IF	(TOOLCHAIN & HITECH)
                                        (0112) ;   jmp   __Start                  ;C compiler fills in this vector
                                        (0113) ELSE
0000: 80 67    JMP   0x0068             (0114)     jmp   __Start                  ;First instruction executed following a Reset
                                        (0115) ENDIF
                                        (0116) 
                                        (0117)     org   04h                      ;Low Voltage Detect (LVD) Interrupt Vector
0002: 30       HALT                     
0003: 30       HALT                     
0004: 30       HALT                     (0118)     halt                           ;Stop execution if power falls too low
                                        (0119) 
                                        (0120)     org   08h                      ;Analog Column 0 Interrupt Vector
                                        (0121)     // call	void_handler
0005: 30       HALT                     
0006: 30       HALT                     
0007: 30       HALT                     
0008: 7E       RETI                     (0122)     reti
                                        (0123) 
                                        (0124)     org   0Ch                      ;Analog Column 1 Interrupt Vector
                                        (0125)     // call	void_handler
0009: 30       HALT                     
000A: 30       HALT                     
000B: 30       HALT                     
000C: 7E       RETI                     (0126)     reti
                                        (0127) 
                                        (0128)     org   10h                      ;Analog Column 2 Interrupt Vector
                                        (0129)     // call	void_handler
000D: 30       HALT                     
000E: 30       HALT                     
000F: 30       HALT                     
0010: 7E       RETI                     (0130)     reti
                                        (0131) 
                                        (0132)     org   14h                      ;Analog Column 3 Interrupt Vector
                                        (0133)     // call	void_handler
0011: 30       HALT                     
0012: 30       HALT                     
0013: 30       HALT                     
0014: 7E       RETI                     (0134)     reti
                                        (0135) 
                                        (0136)     org   18h                      ;VC3 Interrupt Vector
                                        (0137)     // call	void_handler
0015: 30       HALT                     
0016: 30       HALT                     
0017: 30       HALT                     
0018: 7E       RETI                     (0138)     reti
                                        (0139) 
                                        (0140)     org   1Ch                      ;GPIO Interrupt Vector
0019: 30       HALT                     
001A: 30       HALT                     
001B: 30       HALT                     
001C: 7D 07 6B LJMP  PSoC_GPIO_ISR      (0141)     ljmp	PSoC_GPIO_ISR
001F: 7E       RETI                     (0142)     reti
                                        (0143) 
                                        (0144)     org   20h                      ;PSoC Block DBB00 Interrupt Vector
0020: 7D 06 F5 LJMP  0x06F5             (0145)     ljmp	_ADCINCVR_1_CNT_ISR
0023: 7E       RETI                     (0146)     reti
                                        (0147) 
                                        (0148)     org   24h                      ;PSoC Block DBB01 Interrupt Vector
                                        (0149)     // call	void_handler
0024: 7E       RETI                     (0150)     reti
                                        (0151) 
                                        (0152)     org   28h                      ;PSoC Block DCB02 Interrupt Vector
0025: 30       HALT                     
0026: 30       HALT                     
0027: 30       HALT                     
0028: 7D 06 F8 LJMP  0x06F8             (0153)     ljmp	_ADCINCVR_1_PWM16_ISR
002B: 7E       RETI                     (0154)     reti
                                        (0155) 
                                        (0156)     org   2Ch                      ;PSoC Block DCB03 Interrupt Vector
002C: 7D 06 78 LJMP  0x0678             (0157)     ljmp	_ADCINCVR_2_CNT_ISR
002F: 7E       RETI                     (0158)     reti
                                        (0159) 
                                        (0160)     org   30h                      ;PSoC Block DBB10 Interrupt Vector
0030: 7D 05 FB LJMP  0x05FB             (0161)     ljmp	_ADCINCVR_3_CNT_ISR
0033: 7E       RETI                     (0162)     reti
                                        (0163) 
                                        (0164)     org   34h                      ;PSoC Block DBB11 Interrupt Vector
0034: 7D 05 7E LJMP  0x057E             (0165)     ljmp	_ADCINCVR_4_CNT_ISR
0037: 7E       RETI                     (0166)     reti
                                        (0167) 
                                        (0168)     org   38h                      ;PSoC Block DCB12 Interrupt Vector
                                        (0169)     // call	void_handler
0038: 7E       RETI                     (0170)     reti
                                        (0171) 
                                        (0172)     org   3Ch                      ;PSoC Block DCB13 Interrupt Vector
0039: 30       HALT                     
003A: 30       HALT                     
003B: 30       HALT                     
003C: 7D 06 7B LJMP  0x067B             (0173)     ljmp	_ADCINCVR_2_PWM16_ISR
003F: 7E       RETI                     (0174)     reti
                                        (0175) 
                                        (0176)     org   40h                      ;PSoC Block DBB20 Interrupt Vector
                                        (0177)     // call	void_handler
0040: 7E       RETI                     (0178)     reti
                                        (0179) 
                                        (0180)     org   44h                      ;PSoC Block DBB21 Interrupt Vector
0041: 30       HALT                     
0042: 30       HALT                     
0043: 30       HALT                     
0044: 7D 05 FE LJMP  0x05FE             (0181)     ljmp	_ADCINCVR_3_PWM16_ISR
0047: 7E       RETI                     (0182)     reti
                                        (0183) 
                                        (0184)     org   48h                      ;PSoC Block DCB22 Interrupt Vector
                                        (0185)     // call	void_handler
0048: 7E       RETI                     (0186)     reti
                                        (0187) 
                                        (0188)     org   4Ch                      ;PSoC Block DCB23 Interrupt Vector
0049: 30       HALT                     
004A: 30       HALT                     
004B: 30       HALT                     
004C: 7D 05 81 LJMP  0x0581             (0189)     ljmp	_ADCINCVR_4_PWM16_ISR
004F: 7E       RETI                     (0190)     reti
                                        (0191) 
                                        (0192)     org   50h                      ;PSoC Block DBB30 Interrupt Vector
                                        (0193)     // call	void_handler
0050: 7E       RETI                     (0194)     reti
                                        (0195) 
                                        (0196)     org   54h                      ;PSoC Block DBB31 Interrupt Vector
0051: 30       HALT                     
0052: 30       HALT                     
0053: 30       HALT                     
0054: 7D 04 58 LJMP  0x0458             (0197)     ljmp	_Timer16_1_ISR
0057: 7E       RETI                     (0198)     reti
                                        (0199) 
                                        (0200)     org   58h                      ;PSoC Block DCB32 Interrupt Vector
0058: 7D 04 57 LJMP  0x0457             (0201)     ljmp	_TX8_ISR
005B: 7E       RETI                     (0202)     reti
                                        (0203) 
                                        (0204)     org   5Ch                      ;PSoC Block DCB33 Interrupt Vector
                                        (0205)     // call	void_handler
005C: 7E       RETI                     (0206)     reti
                                        (0207) 
                                        (0208)     org   60h                      ;PSoC I2C Interrupt Vector
005D: 30       HALT                     
005E: 30       HALT                     
005F: 30       HALT                     
0060: 7D 04 5A LJMP  0x045A             (0209)     ljmp	_I2CHW_ISR
0063: 7E       RETI                     (0210)     reti
                                        (0211) 
                                        (0212)     org   64h                      ;Sleep Timer Interrupt Vector
                                        (0213)     // call	void_handler
0064: 7E       RETI                     (0214)     reti
                                        (0215) 
                                        (0216) ;-----------------------------------------------------------------------------
                                        (0217) ;  Start of Execution.
                                        (0218) ;-----------------------------------------------------------------------------
                                        (0219) ;  The Supervisory ROM SWBootReset function has already completed the
                                        (0220) ;  calibrate1 process, loading trim values for 5 volt operation.
                                        (0221) ;
                                        (0222) 
                                        (0223) IF	(TOOLCHAIN & HITECH)
                                        (0224)  	AREA PD_startup(CODE, REL, CON)
                                        (0225) ELSE
                                        (0226)     org 68h
                                        (0227) ENDIF
                                        (0228) __Start:
                                        (0229) 
                                        (0230)     ; initialize SMP values for voltage stabilization, if required,
                                        (0231)     ; leaving power-on reset (POR) level at the default (low) level, at
                                        (0232)     ; least for now. 
                                        (0233)     ;
0065: 30       HALT                     
0066: 30       HALT                     
0067: 30       HALT                     
0068: 71 10    OR    F,0x10             (0234)     M8C_SetBank1
006A: 62 FA 00 MOV   REG[0xFA],0x0      (0235)     mov reg[0FAh], 0				;Reset flash location
006D: 62 E3 87 MOV   REG[0xE3],0x87     (0236)     mov   reg[VLT_CR], SWITCH_MODE_PUMP_JUST | LVD_TBEN_JUST | TRIP_VOLTAGE_JUST
0070: 70 EF    AND   F,0xEF             (0237)     M8C_SetBank0
                                        (0238) 
                                        (0239)     ; %53%20%46%46% Apply Erratum 001-05137 workaround
0072: 50 20    MOV   A,0x20             (0240)     mov   A, 20h
0074: 28       ROMX                     (0241)     romx
0075: 50 40    MOV   A,0x40             (0242)     mov   A, 40h
0077: 28       ROMX                     (0243)     romx
0078: 50 60    MOV   A,0x60             (0244)     mov   A, 60h
007A: 28       ROMX                     (0245)     romx
                                        (0246)     ; %45%20%46%46% End workaround
                                        (0247) 
                                        (0248) IF ( WATCHDOG_ENABLE )             ; WDT selected in Global Params
                                        (0249)     M8C_EnableWatchDog
                                        (0250) ENDIF
                                        (0251) 
                                        (0252) IF ( SELECT_32K )
                                        (0253)     or   reg[CPU_SCR1],  CPU_SCR1_ECO_ALLOWED  ; ECO will be used in this project
                                        (0254) ELSE
007B: 41 FE FB AND   REG[0xFE],0xFB     (0255)     and  reg[CPU_SCR1], ~CPU_SCR1_ECO_ALLOWED  ; Prevent ECO from being enabled
                                        (0256) ENDIF
                                        (0257) 
                                        (0258)     ;---------------------------
                                        (0259)     ; Set up the Temporary stack
                                        (0260)     ;---------------------------
                                        (0261)     ; A temporary stack is set up for the SSC instructions.
                                        (0262)     ; The real stack start will be assigned later.
                                        (0263)     ;
                                        (0264) _stack_start:          equ 80h
007E: 50 80    MOV   A,0x80             (0265)     mov   A, _stack_start          ; Set top of stack to end of used RAM
0080: 4E       SWAP  SP,A               (0266)     swap  SP, A                    ; This is only temporary if going to LMM
                                        (0267) 
                                        (0268)     ;-----------------------------------------------
                                        (0269)     ; Set Power-related Trim & the AGND Bypass bit.
                                        (0270)     ;-----------------------------------------------
                                        (0271) 
                                        (0272) IF ( POWER_SETTING & POWER_SET_5V0)            ; *** 5.0 Volt operation   ***
                                        (0273)  IF ( POWER_SETTING & POWER_SET_SLOW_IMO)      ; *** 6MHZ Main Oscillator ***
                                        (0274)     or  reg[CPU_SCR1], CPU_SCR1_SLIMO
                                        (0275)     M8SSC_Set2TableTrims 2, SSCTBL2_TRIM_IMO_5V_6MHZ, 1, SSCTBL1_TRIM_BGR_5V, AGND_BYPASS_JUST
                                        (0276)  ELSE                                          ; *** 12MHZ Main Oscillator ***
                                        (0277)   IF ( AGND_BYPASS )
                                        (0278)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                        (0279)     ; The 5V trim has already been set, but we need to update the AGNDBYP
                                        (0280)     ; bit in the write-only BDG_TR register. Recalculate the register
                                        (0281)     ; value using the proper trim values.
                                        (0282)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                        (0283)     M8SSC_SetTableVoltageTrim 1, SSCTBL1_TRIM_BGR_5V, AGND_BYPASS_JUST
                                        (0284)   ENDIF
                                        (0285)  ENDIF
                                        (0286) ENDIF ; 5.0 V Operation
                                        (0287) 
                                        (0288) IF ( POWER_SETTING & POWER_SET_3V3)            ; *** 3.3 Volt operation   ***
                                        (0289)  IF ( POWER_SETTING & POWER_SET_SLOW_IMO)      ; *** 6MHZ Main Oscillator ***
                                        (0290)     or  reg[CPU_SCR1], CPU_SCR1_SLIMO
                                        (0291)     M8SSC_Set2TableTrims 2, SSCTBL2_TRIM_IMO_3V_6MHZ, 1, SSCTBL1_TRIM_BGR_3V, AGND_BYPASS_JUST
                                        (0292)  ELSE                                          ; *** 12MHZ Main Oscillator ***
                                        (0293)     M8SSC_SetTableTrims  1, SSCTBL1_TRIM_IMO_3V_24MHZ, SSCTBL1_TRIM_BGR_3V, AGND_BYPASS_JUST
                                        (0294)  ENDIF
                                        (0295) ENDIF ; 3.3 Volt Operation
                                        (0296) 
0081: 55 F8 00 MOV   [0xF8],0x0         (0297)     mov  [bSSC_KEY1],  0           ; Lock out Flash and Supervisiory operations
0084: 55 F9 00 MOV   [0xF9],0x0         (0298)     mov  [bSSC_KEYSP], 0
                                        (0299) 
                                        (0300)     ;---------------------------------------
                                        (0301)     ; Initialize Crystal Oscillator and PLL
                                        (0302)     ;---------------------------------------
                                        (0303) 
                                        (0304) IF ( SELECT_32K & WAIT_FOR_32K )
                                        (0305)     ; If the user has requested the External Crystal Oscillator (ECO) then turn it
                                        (0306)     ; on and wait for it to stabilize and the system to switch over to it. The PLL
                                        (0307)     ; is left off. Set the SleepTimer period is set to 1 sec to time the wait for
                                        (0308)     ; the ECO to stabilize.
                                        (0309)     ;
                                        (0310)     M8C_SetBank1
                                        (0311)     mov   reg[OSC_CR0], (SELECT_32K_JUST | OSC_CR0_SLEEP_1Hz | OSC_CR0_CPU_12MHz)
                                        (0312)     M8C_SetBank0
                                        (0313)     M8C_ClearWDTAndSleep                  ; Reset the sleep timer to get a full second
                                        (0314)     or    reg[INT_MSK0], INT_MSK0_SLEEP   ; Enable latching of SleepTimer interrupt
                                        (0315)     mov   reg[INT_VC],   0                ; Clear all pending interrupts
                                        (0316) .WaitFor1s:
                                        (0317)     tst   reg[INT_CLR0], INT_MSK0_SLEEP   ; Test the SleepTimer Interrupt Status
                                        (0318)     jz   .WaitFor1s                       ; Interrupt will latch but will not dispatch
                                        (0319)                                           ;   since interrupts are not globally enabled
                                        (0320) ELSE ; !( SELECT_32K & WAIT_FOR_32K )
                                        (0321)     ; Either no ECO, or waiting for stable clock is to be done in main
0087: 71 10    OR    F,0x10             (0322)     M8C_SetBank1
0089: 62 E0 02 MOV   REG[0xE0],0x2      (0323)     mov   reg[OSC_CR0], (SELECT_32K_JUST | PLL_MODE_JUST | SLEEP_TIMER_JUST | OSC_CR0_CPU_12MHz)
008C: 70 EF    AND   F,0xEF             (0324)     M8C_SetBank0
008E: 62 E3 38 MOV   REG[0xE3],0x38     (0325)     M8C_ClearWDTAndSleep           ; Reset the watch dog
                                        (0326) 
                                        (0327) ENDIF ;( SELECT_32K & WAIT_FOR_32K )
                                        (0328) 
                                        (0329) IF ( PLL_MODE )
                                        (0330)     ; Crystal is now fully operational (assuming WAIT_FOR_32K was enabled).
                                        (0331)     ; Now start up PLL if selected, and wait 16 msec for it to stabilize.
                                        (0332)     ;
                                        (0333)     M8C_SetBank1
                                        (0334)     mov   reg[OSC_CR0], (SELECT_32K_JUST | PLL_MODE_JUST | OSC_CR0_SLEEP_64Hz | OSC_CR0_CPU_3MHz)
                                        (0335)     M8C_SetBank0
                                        (0336)     M8C_ClearWDTAndSleep                  ; Reset the sleep timer to get full period
                                        (0337)     mov   reg[INT_VC], 0                  ; Clear all pending interrupts
                                        (0338) 
                                        (0339) .WaitFor16ms:
                                        (0340)     tst   reg[INT_CLR0],INT_MSK0_SLEEP    ; Test the SleepTimer Interrupt Status
                                        (0341)     jz   .WaitFor16ms
                                        (0342)     M8C_SetBank1                          ; continue boot at CPU Speed of SYSCLK/2
                                        (0343)     mov   reg[OSC_CR0], (SELECT_32K_JUST | PLL_MODE_JUST | OSC_CR0_SLEEP_64Hz | OSC_CR0_CPU_12MHz)
                                        (0344)     M8C_SetBank0
                                        (0345) 
                                        (0346) IF      ( WAIT_FOR_32K )
                                        (0347) ELSE ; !( WAIT_FOR_32K )
                                        (0348)     ; Option settings (PLL-Yes, ECO-No) are incompatible - force a syntax error
                                        (0349)     ERROR_PSoC Disabling WAIT_FOR_32K requires that the PLL_Lock must be enabled in user code.
                                        (0350) ENDIF ;(WAIT_FOR_32K)
                                        (0351) ENDIF ;(PLL_MODE)
                                        (0352) 
                                        (0353)     ;------------------------
                                        (0354)     ; Close CT leakage path.
                                        (0355)     ;------------------------
0091: 62 71 05 MOV   REG[0x71],0x5      (0356)     mov   reg[ACB00CR0], 05h
0094: 62 75 05 MOV   REG[0x75],0x5      (0357)     mov   reg[ACB01CR0], 05h
0097: 62 79 05 MOV   REG[0x79],0x5      (0358)     mov   reg[ACB02CR0], 05h
009A: 62 7D 05 MOV   REG[0x7D],0x5      (0359)     mov   reg[ACB03CR0], 05h
                                        (0360) 
                                        (0361) 
                                        (0362) IF	(TOOLCHAIN & HITECH)
                                        (0363)     ;---------------------------------------------
                                        (0364)     ; HI-TECH initialization: Enter the Large Memory Model, if applicable
                                        (0365)     ;---------------------------------------------
                                        (0366) 	global		__Lstackps
                                        (0367) 	mov     a,low __Lstackps
                                        (0368) 	swap    a,sp
                                        (0369) 
                                        (0370) IF ( SYSTEM_LARGE_MEMORY_MODEL )
                                        (0371)     RAM_SETPAGE_STK SYSTEM_STACK_PAGE      ; relocate stack page ...
                                        (0372)     RAM_SETPAGE_IDX2STK            ; initialize other page pointers
                                        (0373)     RAM_SETPAGE_CUR 0
                                        (0374)     RAM_SETPAGE_MVW 0
                                        (0375)     RAM_SETPAGE_MVR 0
                                        (0376)     IF ( SYSTEM_IDXPG_TRACKS_STK_PP ); Now enable paging:
                                        (0377)     or    F, FLAG_PGMODE_11b       ; LMM w/ IndexPage<==>StackPage
                                        (0378)     ELSE
                                        (0379)     or    F, FLAG_PGMODE_10b       ; LMM w/ independent IndexPage
                                        (0380)     ENDIF ;  SYSTEM_IDXPG_TRACKS_STK_PP
                                        (0381) ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
                                        (0382) ELSE
                                        (0383)     ;---------------------------------------------
                                        (0384)     ; ImageCraft Enter the Large Memory Model, if applicable
                                        (0385)     ;---------------------------------------------
                                        (0386) IF ( SYSTEM_LARGE_MEMORY_MODEL )
009D: 62 D1 07 MOV   REG[0xD1],0x7      (0387)     RAM_SETPAGE_STK SYSTEM_STACK_PAGE      ; relocate stack page ...
00A0: 50 00    MOV   A,0x0              (0388)     mov   A, SYSTEM_STACK_BASE_ADDR        ;   and offset, if any
00A2: 4E       SWAP  SP,A               (0389)     swap  A, SP
00A3: 62 D3 07 MOV   REG[0xD3],0x7      (0390)     RAM_SETPAGE_IDX2STK            ; initialize other page pointers
00A6: 62 D0 00 MOV   REG[0xD0],0x0      (0391)     RAM_SETPAGE_CUR 0
00A9: 62 D5 00 MOV   REG[0xD5],0x0      (0392)     RAM_SETPAGE_MVW 0
00AC: 62 D4 00 MOV   REG[0xD4],0x0      (0393)     RAM_SETPAGE_MVR 0
                                        (0394) 
                                        (0395)   IF ( SYSTEM_IDXPG_TRACKS_STK_PP ); Now enable paging:
00AF: 71 C0    OR    F,0xC0             (0396)     or    F, FLAG_PGMODE_11b       ; LMM w/ IndexPage<==>StackPage
                                        (0397)   ELSE
                                        (0398)     or    F, FLAG_PGMODE_10b       ; LMM w/ independent IndexPage
                                        (0399)   ENDIF ;  SYSTEM_IDXPG_TRACKS_STK_PP
                                        (0400) ELSE
                                        (0401)     mov   A, __ramareas_end        ; Set top of stack to end of used RAM
                                        (0402)     swap  SP, A
                                        (0403) ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
                                        (0404) ENDIF ;	TOOLCHAIN
                                        (0405) 
                                        (0406)     ;-------------------------
                                        (0407)     ; Load Base Configuration
                                        (0408)     ;-------------------------
                                        (0409)     ; Load global parameter settings and load the user modules in the
                                        (0410)     ; base configuration. Exceptions: (1) Leave CPU Speed fast as possible
                                        (0411)     ; to minimize start up time; (2) We may still need to play with the
                                        (0412)     ; Sleep Timer.
                                        (0413)     ;
00B1: 7C 03 F5 LCALL 0x03F5             (0414)     lcall LoadConfigInit
                                        (0415) 
                                        (0416)     ;-----------------------------------
                                        (0417)     ; Initialize C Run-Time Environment
                                        (0418)     ;-----------------------------------
                                        (0419) IF ( C_LANGUAGE_SUPPORT )
                                        (0420) IF ( SYSTEM_SMALL_MEMORY_MODEL )
                                        (0421)     mov  A,0                           ; clear the 'bss' segment to zero
                                        (0422)     mov  [__r0],<__bss_start
                                        (0423) BssLoop:
                                        (0424)     cmp  [__r0],<__bss_end
                                        (0425)     jz   BssDone
                                        (0426)     mvi  [__r0],A
                                        (0427)     jmp  BssLoop
                                        (0428) BssDone:
                                        (0429)     mov  A,>__idata_start              ; copy idata to data segment
                                        (0430)     mov  X,<__idata_start
                                        (0431)     mov  [__r0],<__data_start
                                        (0432) IDataLoop:
                                        (0433)     cmp  [__r0],<__data_end
                                        (0434)     jz   C_RTE_Done
                                        (0435)     push A
                                        (0436)     romx
                                        (0437)     mvi  [__r0],A
                                        (0438)     pop  A
                                        (0439)     inc  X
                                        (0440)     adc  A,0
                                        (0441)     jmp  IDataLoop
                                        (0442) 
                                        (0443) ENDIF ; SYSTEM_SMALL_MEMORY_MODEL
                                        (0444) 
                                        (0445) IF ( SYSTEM_LARGE_MEMORY_MODEL )
00B4: 62 D0 00 MOV   REG[0xD0],0x0      (0446)     mov   reg[CUR_PP], >__r0           ; force direct addr mode instructions
                                        (0447)                                        ; to use the Virtual Register page.
                                        (0448) 
                                        (0449)     ; Dereference the constant (flash) pointer pXIData to access the start
                                        (0450)     ; of the extended idata area, "xidata." Xidata follows the end of the
                                        (0451)     ; text segment and may have been relocated by the Code Compressor.
                                        (0452)     ;
00B7: 50 03    MOV   A,0x3              (0453)     mov   A, >__pXIData                ; Get the address of the flash
00B9: 57 F3    MOV   X,0xF3             (0454)     mov   X, <__pXIData                ;   pointer to the xidata area.
00BB: 08       PUSH  A                  (0455)     push  A
00BC: 28       ROMX                     (0456)     romx                               ; get the MSB of xidata's address
00BD: 53 1D    MOV   [__r0],A           (0457)     mov   [__r0], A
00BF: 18       POP   A                  (0458)     pop   A
00C0: 75       INC   X                  (0459)     inc   X
00C1: 09 00    ADC   A,0x0              (0460)     adc   A, 0
00C3: 28       ROMX                     (0461)     romx                               ; get the LSB of xidata's address
00C4: 4B       SWAP  A,X                (0462)     swap  A, X
00C5: 51 1D    MOV   A,[__r0]           (0463)     mov   A, [__r0]                    ; pXIData (in [A,X]) points to the
                                        (0464)                                        ;   XIData structure list in flash
00C7: 80 04    JMP   0x00CC             (0465)     jmp   .AccessStruct
                                        (0466) 
                                        (0467)     ; Unpack one element in the xidata "structure list" that specifies the
                                        (0468)     ; values of C variables. Each structure contains 3 member elements.
                                        (0469)     ; The first is a pointer to a contiguous block of RAM to be initial-
                                        (0470)     ; ized. Blocks are always 255 bytes or less in length and never cross
                                        (0471)     ; RAM page boundaries. The list terminates when the MSB of the pointer
                                        (0472)     ; contains 0xFF. There are two formats for the struct depending on the
                                        (0473)     ; value in the second member element, an unsigned byte:
                                        (0474)     ; (1) If the value of the second element is non-zero, it represents
                                        (0475)     ; the 'size' of the block of RAM to be initialized. In this case, the
                                        (0476)     ; third member of the struct is an array of bytes of length 'size' and
                                        (0477)     ; the bytes are copied to the block of RAM.
                                        (0478)     ; (2) If the value of the second element is zero, the block of RAM is
                                        (0479)     ; to be cleared to zero. In this case, the third member of the struct
                                        (0480)     ; is an unsigned byte containing the number of bytes to clear.
                                        (0481) 
                                        (0482) .AccessNextStructLoop:
00C9: 75       INC   X                  (0483)     inc   X                            ; pXIData++
00CA: 09 00    ADC   A,0x0              (0484)     adc   A, 0
                                        (0485) .AccessStruct:                         ; Entry point for first block
                                        (0486)     ;
                                        (0487)     ; Assert: pXIData in [A,X] points to the beginning of an XIData struct.
                                        (0488)     ;
00CC: 62 E3 00 MOV   REG[0xE3],0x0      (0489)     M8C_ClearWDT                       ; Clear the watchdog for long inits
00CF: 08       PUSH  A                  (0490)     push  A
00D0: 28       ROMX                     (0491)     romx                               ; MSB of RAM addr (CPU.A <- *pXIData)
00D1: 60 D5    MOV   REG[0xD5],A        (0492)     mov   reg[MVW_PP], A               ;   for use with MVI write operations
00D3: 74       INC   A                  (0493)     inc   A                            ; End of Struct List? (MSB==0xFF?)
00D4: A0 4B    JZ    0x0120             (0494)     jz    .C_RTE_WrapUp                ;   Yes, C runtime environment complete
00D6: 18       POP   A                  (0495)     pop   A                            ; restore pXIData to [A,X]
00D7: 75       INC   X                  (0496)     inc   X                            ; pXIData++
00D8: 09 00    ADC   A,0x0              (0497)     adc   A, 0
00DA: 08       PUSH  A                  (0498)     push  A
00DB: 28       ROMX                     (0499)     romx                               ; LSB of RAM addr (CPU.A <- *pXIData)
00DC: 53 1D    MOV   [__r0],A           (0500)     mov   [__r0], A                    ; RAM Addr now in [reg[MVW_PP],[__r0]]
00DE: 18       POP   A                  (0501)     pop   A                            ; restore pXIData to [A,X]
00DF: 75       INC   X                  (0502)     inc   X                            ; pXIData++ (point to size)
00E0: 09 00    ADC   A,0x0              (0503)     adc   A, 0
00E2: 08       PUSH  A                  (0504)     push  A
00E3: 28       ROMX                     (0505)     romx                               ; Get the size (CPU.A <- *pXIData)
00E4: A0 1C    JZ    0x0101             (0506)     jz    .ClearRAMBlockToZero         ; If Size==0, then go clear RAM
00E6: 53 1C    MOV   [__r1],A           (0507)     mov   [__r1], A                    ;             else downcount in __r1
00E8: 18       POP   A                  (0508)     pop   A                            ; restore pXIData to [A,X]
                                        (0509) 
                                        (0510) .CopyNextByteLoop:
                                        (0511)     ; For each byte in the structure's array member, copy from flash to RAM.
                                        (0512)     ; Assert: pXIData in [A,X] points to previous byte of flash source;
                                        (0513)     ;         [reg[MVW_PP],[__r0]] points to next RAM destination;
                                        (0514)     ;         __r1 holds a non-zero count of the number of bytes remaining.
                                        (0515)     ;
00E9: 75       INC   X                  (0516)     inc   X                            ; pXIData++ (point to next data byte)
00EA: 09 00    ADC   A,0x0              (0517)     adc   A, 0
00EC: 08       PUSH  A                  (0518)     push  A
00ED: 28       ROMX                     (0519)     romx                               ; Get the data value (CPU.A <- *pXIData)
00EE: 3F 1D    MVI   [__r0],A           (0520)     mvi   [__r0], A                    ; Transfer the data to RAM
00F0: 47 1D FF TST   [__r0],0xFF        (0521)     tst   [__r0], 0xff                 ; Check for page crossing
00F3: B0 06    JNZ   0x00FA             (0522)     jnz   .CopyLoopTail                ;   No crossing, keep going
00F5: 5D D5    MOV   A,REG[0xD5]        (0523)     mov   A, reg[ MVW_PP]              ;   If crossing, bump MVW page reg
00F7: 74       INC   A                  (0524)     inc   A
00F8: 60 D5    MOV   REG[0xD5],A        (0525)     mov   reg[ MVW_PP], A
                                        (0526) .CopyLoopTail:
00FA: 18       POP   A                  (0527)     pop   A                            ; restore pXIData to [A,X]
00FB: 7A 1C    DEC   [__r1]             (0528)     dec   [__r1]                       ; End of this array in flash?
00FD: BF EB    JNZ   0x00E9             (0529)     jnz   .CopyNextByteLoop            ;   No,  more bytes to copy
00FF: 8F C9    JMP   0x00C9             (0530)     jmp   .AccessNextStructLoop        ;   Yes, initialize another RAM block
                                        (0531) 
                                        (0532) .ClearRAMBlockToZero:
0101: 18       POP   A                  (0533)     pop   A                            ; restore pXIData to [A,X]
0102: 75       INC   X                  (0534)     inc   X                            ; pXIData++ (point to next data byte)
0103: 09 00    ADC   A,0x0              (0535)     adc   A, 0
0105: 08       PUSH  A                  (0536)     push  A
0106: 28       ROMX                     (0537)     romx                               ; Get the run length (CPU.A <- *pXIData)
0107: 53 1C    MOV   [__r1],A           (0538)     mov   [__r1], A                    ; Initialize downcounter
0109: 50 00    MOV   A,0x0              (0539)     mov   A, 0                         ; Initialize source data
                                        (0540) 
                                        (0541) .ClearRAMBlockLoop:
                                        (0542)     ; Assert: [reg[MVW_PP],[__r0]] points to next RAM destination and
                                        (0543)     ;         __r1 holds a non-zero count of the number of bytes remaining.
                                        (0544)     ;
010B: 3F 1D    MVI   [__r0],A           (0545)     mvi   [__r0], A                    ; Clear a byte
010D: 47 1D FF TST   [__r0],0xFF        (0546)     tst   [__r0], 0xff                 ; Check for page crossing
0110: B0 08    JNZ   0x0119             (0547)     jnz   .ClearLoopTail               ;   No crossing, keep going
0112: 5D D5    MOV   A,REG[0xD5]        (0548)     mov   A, reg[ MVW_PP]              ;   If crossing, bump MVW page reg
0114: 74       INC   A                  (0549)     inc   A
0115: 60 D5    MOV   REG[0xD5],A        (0550)     mov   reg[ MVW_PP], A
0117: 50 00    MOV   A,0x0              (0551)     mov   A, 0                         ; Restore the zero used for clearing
                                        (0552) .ClearLoopTail:
0119: 7A 1C    DEC   [__r1]             (0553)     dec   [__r1]                       ; Was this the last byte?
011B: BF EF    JNZ   0x010B             (0554)     jnz   .ClearRAMBlockLoop           ;   No,  continue
011D: 18       POP   A                  (0555)     pop   A                            ;   Yes, restore pXIData to [A,X] and
011E: 8F AA    JMP   0x00C9             (0556)     jmp   .AccessNextStructLoop        ;        initialize another RAM block
                                        (0557) 
                                        (0558) .C_RTE_WrapUp:
0120: 18       POP   A                  (0559)     pop   A                            ; balance stack
                                        (0560) 
                                        (0561) ENDIF ; SYSTEM_LARGE_MEMORY_MODEL
                                        (0562) 
                                        (0563) C_RTE_Done:
                                        (0564) 
                                        (0565) ENDIF ; C_LANGUAGE_SUPPORT
                                        (0566) 
                                        (0567)     ;-------------------------------
                                        (0568)     ; Voltage Stabilization for SMP
                                        (0569)     ;-------------------------------
                                        (0570) 
                                        (0571) IF ( POWER_SETTING & POWER_SET_5V0)    ; 5.0V Operation
                                        (0572) IF ( SWITCH_MODE_PUMP ^ 1 )            ; SMP is operational
                                        (0573)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                        (0574)     ; When using the SMP at 5V, we must wait for Vdd to slew from 3.1V to
                                        (0575)     ; 5V before enabling the Precision Power-On Reset (PPOR).
                                        (0576)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                        (0577)     or   reg[INT_MSK0],INT_MSK0_SLEEP
                                        (0578)     M8C_SetBank1
                                        (0579)     and   reg[OSC_CR0], ~OSC_CR0_SLEEP
                                        (0580)     or    reg[OSC_CR0],  OSC_CR0_SLEEP_512Hz
                                        (0581)     M8C_SetBank0
                                        (0582)     M8C_ClearWDTAndSleep                   ; Restart the sleep timer
                                        (0583)     mov   reg[INT_VC], 0                   ; Clear all pending interrupts
                                        (0584) .WaitFor2ms:
                                        (0585)     tst   reg[INT_CLR0], INT_MSK0_SLEEP    ; Test the SleepTimer Interrupt Status
                                        (0586)     jz   .WaitFor2ms                       ; Branch fails when 2 msec has passed
                                        (0587) ENDIF ; SMP is operational
                                        (0588) ENDIF ; 5.0V Operation
                                        (0589) 
                                        (0590)     ;-------------------------------
                                        (0591)     ; Set Power-On Reset (POR) Level
                                        (0592)     ;-------------------------------
                                        (0593) 
                                        (0594)     ;  The writes to the VLT_CR register below include setting the POR to VLT_CR_POR_HIGH,
                                        (0595)     ;  VLT_CR_POR_MID or VLT_CR_POR_LOW. Correctly setting this value is critical to the proper
                                        (0596)     ;  operation of the PSoC. The POR protects the M8C from mis-executing when Vdd falls low. These
                                        (0597)     ;  values should not be changed from the settings here. Failure to follow this instruction could 
                                        (0598)     ;  lead to corruption of PSoC flash.
                                        (0599) 
0121: 71 10    OR    F,0x10             (0600)     M8C_SetBank1
                                        (0601) 
                                        (0602) IF (POWER_SETTING & POWER_SET_5V0)          ; 5.0V Operation?
                                        (0603)  IF (POWER_SETTING & POWER_SET_SLOW_IMO)    ; and Slow Mode?
                                        (0604)  ELSE                                       ;    No, fast mode
                                        (0605)   IF ( CPU_CLOCK_JUST ^ OSC_CR0_CPU_24MHz ) ;    As fast as 24MHz?
                                        (0606)                                             ;       no, set midpoint POR in user code, if desired
                                        (0607)   ELSE ; 24HMz                              ;
                                        (0608)     or    reg[VLT_CR],  VLT_CR_POR_HIGH     ;      yes, highest POR trip point required
                                        (0609)   ENDIF ; 24MHz
                                        (0610)  ENDIF ; Slow Mode
                                        (0611) ENDIF ; 5.0V Operation
                                        (0612) 
0123: 70 EF    AND   F,0xEF             (0613)     M8C_SetBank0
                                        (0614) 
                                        (0615)     ;----------------------------
                                        (0616)     ; Wrap up and invoke "main"
                                        (0617)     ;----------------------------
                                        (0618) 
                                        (0619)     ; Disable the Sleep interrupt that was used for timing above.  In fact,
                                        (0620)     ; no interrupts should be enabled now, so may as well clear the register.
                                        (0621)     ;
0125: 62 E0 00 MOV   REG[0xE0],0x0      (0622)     mov  reg[INT_MSK0],0
                                        (0623) 
                                        (0624)     ; Everything has started OK. Now select requested CPU & sleep frequency.
                                        (0625)     ; And put decimator in full mode so it does not consume too much current.
                                        (0626)     ;
0128: 71 10    OR    F,0x10             (0627)     M8C_SetBank1
012A: 62 E0 00 MOV   REG[0xE0],0x0      (0628)     mov  reg[OSC_CR0],(SELECT_32K_JUST | PLL_MODE_JUST | SLEEP_TIMER_JUST | CPU_CLOCK_JUST)
012D: 43 E7 80 OR    REG[0xE7],0x80     (0629)     or   reg[DEC_CR2],80h                    ; Put decimator in full mode
0130: 70 EF    AND   F,0xEF             (0630)     M8C_SetBank0
                                        (0631) 
                                        (0632)     ; Global Interrupt are NOT enabled, this should be done in main().
                                        (0633)     ; LVD is set but will not occur unless Global Interrupts are enabled.
                                        (0634)     ; Global Interrupts should be enabled as soon as possible in main().
                                        (0635)     ;
0132: 62 E2 00 MOV   REG[0xE2],0x0      (0636)     mov  reg[INT_VC],0             ; Clear any pending interrupts which may
                                        (0637)                                    ; have been set during the boot process.
                                        (0638) IF	(TOOLCHAIN & HITECH)
                                        (0639) 	ljmp  startup                  ; Jump to C compiler startup code
                                        (0640) ELSE
                                        (0641) IF ENABLE_LJMP_TO_MAIN
                                        (0642)     ljmp  _main                    ; goto main (no return)
                                        (0643) ELSE
0135: 7C 07 64 LCALL _main|__text_start|_main(0644)     lcall _main                    ; call main
                                        (0645) .Exit:
0138: 8F FF    JMP   0x0138             (0646)     jmp  .Exit                     ; Wait here after return till power-off or reset
                                        (0647) ENDIF
                                        (0648) ENDIF ; TOOLCHAIN
                                        (0649) 
                                        (0650)     ;---------------------------------
                                        (0651)     ; Library Access to Global Parms
                                        (0652)     ;---------------------------------
                                        (0653)     ;
                                        (0654)  bGetPowerSetting:
                                        (0655) _bGetPowerSetting:
                                        (0656)     ; Returns value of POWER_SETTING in the A register.
                                        (0657)     ; No inputs. No Side Effects.
                                        (0658)     ;
013A: 50 10    MOV   A,0x10             (0659)     mov   A, POWER_SETTING
013C: 7F       RET                      (0660)     ret
(0661) 
(0662) IF	(TOOLCHAIN & HITECH)
(0663) ELSE
(0664)     ;---------------------------------
(0665)     ; Order Critical RAM & ROM AREAs
(0666)     ;---------------------------------
(0667)     ;  'TOP' is all that has been defined so far...
(0668) 
(0669)     ;  ROM AREAs for C CONST, static & global items
(0670)     ;
(0671)     AREA lit               (ROM, REL, CON)   ; 'const' definitions
(0672)     AREA idata             (ROM, REL, CON)   ; Constants for initializing RAM
(0673) __idata_start:
(0674) 
(0675)     AREA func_lit          (ROM, REL, CON)   ; Function Pointers
(0676) __func_lit_start:
(0677) 
(0678) IF ( SYSTEM_LARGE_MEMORY_MODEL )
(0679)     ; We use the func_lit area to store a pointer to extended initialized
(0680)     ; data (xidata) area that follows the text area. Func_lit isn't
(0681)     ; relocated by the code compressor, but the text area may shrink and
(0682)     ; that moves xidata around.
(0683)     ;
(0684) __pXIData:         word __text_end           ; ptr to extended idata
(0685) ENDIF
(0686) 
(0687)     AREA psoc_config       (ROM, REL, CON)   ; Configuration Load & Unload
(0688)     AREA UserModules       (ROM, REL, CON)   ; User Module APIs
(0689) 
(0690)     ; CODE segment for general use
(0691)     ;
(0692)     AREA text (ROM, REL, CON)
(0693) __text_start:
(0694) 
(0695)     ; RAM area usage
(0696)     ;
(0697)     AREA data              (RAM, REL, CON)   ; initialized RAM
(0698) __data_start:
(0699) 
(0700)     AREA virtual_registers (RAM, REL, CON)   ; Temp vars of C compiler
(0701)     AREA InterruptRAM      (RAM, REL, CON)   ; Interrupts, on Page 0
(0702)     AREA bss               (RAM, REL, CON)   ; general use
(0703) __bss_start:
(0704) 
(0705) ENDIF ; TOOLCHAIN
(0706) 
(0707) ; end of file boot.asm
FILE: lib\psocconfigtbl.asm
                                        (0001) ; Generated by PSoC Designer 5.0.1127.0
                                        (0002) ;
                                        (0003) include "m8c.inc"
                                        (0004) ;  Personalization tables 
                                        (0005) export LoadConfigTBL_box_slave_Bank1
                                        (0006) export LoadConfigTBL_box_slave_Bank0
                                        (0007) export LoadConfigTBL_box_slave_Ordered
                                        (0008) AREA lit(rom, rel)
                                        (0009) LoadConfigTBL_box_slave_Bank0:
                                        (0010) ;  Instance name ADCINCVR_1, User Module ADCINCVR
                                        (0011) ;       Instance name ADCINCVR_1, Block Name ADC(ASC10)
                                        (0012) 	db		80h, 90h		;ADCINCVR_1_bfAtoDcr0       (ASC10CR0)
                                        (0013) 	db		81h, 00h		;ADCINCVR_1_bfAtoDcr1       (ASC10CR1)
                                        (0014) 	db		82h, 61h		;ADCINCVR_1_bfAtoDcr2       (ASC10CR2)
                                        (0015) 	db		83h, f0h		;ADCINCVR_1_bfAtoDcr3       (ASC10CR3)
                                        (0016) ;       Instance name ADCINCVR_1, Block Name CNT(DBB00)
                                        (0017) 	db		23h, 00h		;ADCINCVR_1_bCounter_CR0    (DBB00CR0)
                                        (0018) 	db		21h, 00h		;ADCINCVR_1_bPeriod         (DBB00DR1)
                                        (0019) 	db		22h, 00h		;ADCINCVR_1_bCompare        (DBB00DR2)
                                        (0020) ;       Instance name ADCINCVR_1, Block Name PWM16_LSB(DBB01)
                                        (0021) 	db		27h, 00h		;ADCINCVR_1_fPWM_LSB_CR0    (DBB01CR0)
                                        (0022) 	db		25h, 00h		;ADCINCVR_1_bPWM_Period_LSB (DBB01DR1)
                                        (0023) 	db		26h, 00h		;ADCINCVR_1_bPWM_IntTime_LSB(DBB01DR2)
                                        (0024) ;       Instance name ADCINCVR_1, Block Name PWM16_MSB(DCB02)
                                        (0025) 	db		2bh, 00h		;ADCINCVR_1_fPWM_MSB_CR0    (DCB02CR0)
                                        (0026) 	db		29h, 00h		;ADCINCVR_1_bPWM_Period_MSB (DCB02DR1)
                                        (0027) 	db		2ah, 00h		;ADCINCVR_1_bPWM_IntTime_MSB(DCB02DR2)
                                        (0028) ;  Instance name ADCINCVR_2, User Module ADCINCVR
                                        (0029) ;       Instance name ADCINCVR_2, Block Name ADC(ASD11)
                                        (0030) 	db		84h, 90h		;ADCINCVR_2_bfAtoDcr0       (ASD11CR0)
                                        (0031) 	db		85h, 00h		;ADCINCVR_2_bfAtoDcr1       (ASD11CR1)
                                        (0032) 	db		86h, 61h		;ADCINCVR_2_bfAtoDcr2       (ASD11CR2)
                                        (0033) 	db		87h, f0h		;ADCINCVR_2_bfAtoDcr3       (ASD11CR3)
                                        (0034) ;       Instance name ADCINCVR_2, Block Name CNT(DCB03)
                                        (0035) 	db		2fh, 00h		;ADCINCVR_2_bCounter_CR0    (DCB03CR0)
                                        (0036) 	db		2dh, 00h		;ADCINCVR_2_bPeriod         (DCB03DR1)
                                        (0037) 	db		2eh, 00h		;ADCINCVR_2_bCompare        (DCB03DR2)
                                        (0038) ;       Instance name ADCINCVR_2, Block Name PWM16_LSB(DCB12)
                                        (0039) 	db		3bh, 00h		;ADCINCVR_2_fPWM_LSB_CR0    (DCB12CR0)
                                        (0040) 	db		39h, 00h		;ADCINCVR_2_bPWM_Period_LSB (DCB12DR1)
                                        (0041) 	db		3ah, 00h		;ADCINCVR_2_bPWM_IntTime_LSB(DCB12DR2)
                                        (0042) ;       Instance name ADCINCVR_2, Block Name PWM16_MSB(DCB13)
                                        (0043) 	db		3fh, 00h		;ADCINCVR_2_fPWM_MSB_CR0    (DCB13CR0)
                                        (0044) 	db		3dh, 00h		;ADCINCVR_2_bPWM_Period_MSB (DCB13DR1)
                                        (0045) 	db		3eh, 00h		;ADCINCVR_2_bPWM_IntTime_MSB(DCB13DR2)
                                        (0046) ;  Instance name ADCINCVR_3, User Module ADCINCVR
                                        (0047) ;       Instance name ADCINCVR_3, Block Name ADC(ASC12)
                                        (0048) 	db		88h, 90h		;ADCINCVR_3_bfAtoDcr0       (ASC12CR0)
                                        (0049) 	db		89h, 00h		;ADCINCVR_3_bfAtoDcr1       (ASC12CR1)
                                        (0050) 	db		8ah, 61h		;ADCINCVR_3_bfAtoDcr2       (ASC12CR2)
                                        (0051) 	db		8bh, f0h		;ADCINCVR_3_bfAtoDcr3       (ASC12CR3)
                                        (0052) ;       Instance name ADCINCVR_3, Block Name CNT(DBB10)
                                        (0053) 	db		33h, 00h		;ADCINCVR_3_bCounter_CR0    (DBB10CR0)
                                        (0054) 	db		31h, 00h		;ADCINCVR_3_bPeriod         (DBB10DR1)
                                        (0055) 	db		32h, 00h		;ADCINCVR_3_bCompare        (DBB10DR2)
                                        (0056) ;       Instance name ADCINCVR_3, Block Name PWM16_LSB(DBB20)
                                        (0057) 	db		43h, 00h		;ADCINCVR_3_fPWM_LSB_CR0    (DBB20CR0)
                                        (0058) 	db		41h, 00h		;ADCINCVR_3_bPWM_Period_LSB (DBB20DR1)
                                        (0059) 	db		42h, 00h		;ADCINCVR_3_bPWM_IntTime_LSB(DBB20DR2)
                                        (0060) ;       Instance name ADCINCVR_3, Block Name PWM16_MSB(DBB21)
                                        (0061) 	db		47h, 00h		;ADCINCVR_3_fPWM_MSB_CR0    (DBB21CR0)
                                        (0062) 	db		45h, 00h		;ADCINCVR_3_bPWM_Period_MSB (DBB21DR1)
                                        (0063) 	db		46h, 00h		;ADCINCVR_3_bPWM_IntTime_MSB(DBB21DR2)
                                        (0064) ;  Instance name ADCINCVR_4, User Module ADCINCVR
                                        (0065) ;       Instance name ADCINCVR_4, Block Name ADC(ASD13)
                                        (0066) 	db		8ch, 90h		;ADCINCVR_4_bfAtoDcr0       (ASD13CR0)
                                        (0067) 	db		8dh, 00h		;ADCINCVR_4_bfAtoDcr1       (ASD13CR1)
                                        (0068) 	db		8eh, 61h		;ADCINCVR_4_bfAtoDcr2       (ASD13CR2)
                                        (0069) 	db		8fh, f0h		;ADCINCVR_4_bfAtoDcr3       (ASD13CR3)
                                        (0070) ;       Instance name ADCINCVR_4, Block Name CNT(DBB11)
                                        (0071) 	db		37h, 00h		;ADCINCVR_4_bCounter_CR0    (DBB11CR0)
                                        (0072) 	db		35h, 00h		;ADCINCVR_4_bPeriod         (DBB11DR1)
                                        (0073) 	db		36h, 00h		;ADCINCVR_4_bCompare        (DBB11DR2)
                                        (0074) ;       Instance name ADCINCVR_4, Block Name PWM16_LSB(DCB22)
                                        (0075) 	db		4bh, 00h		;ADCINCVR_4_fPWM_LSB_CR0    (DCB22CR0)
                                        (0076) 	db		49h, 00h		;ADCINCVR_4_bPWM_Period_LSB (DCB22DR1)
                                        (0077) 	db		4ah, 00h		;ADCINCVR_4_bPWM_IntTime_LSB(DCB22DR2)
                                        (0078) ;       Instance name ADCINCVR_4, Block Name PWM16_MSB(DCB23)
                                        (0079) 	db		4fh, 00h		;ADCINCVR_4_fPWM_MSB_CR0    (DCB23CR0)
                                        (0080) 	db		4dh, 00h		;ADCINCVR_4_bPWM_Period_MSB (DCB23DR1)
                                        (0081) 	db		4eh, 00h		;ADCINCVR_4_bPWM_IntTime_MSB(DCB23DR2)
                                        (0082) ;  Instance name I2CHW, User Module I2CHW
                                        (0083) ;  Instance name PGA_1, User Module PGA
                                        (0084) ;       Instance name PGA_1, Block Name GAIN(ACB00)
                                        (0085) 	db		71h, feh		;PGA_1_GAIN_CR0(ACB00CR0)
                                        (0086) 	db		72h, 21h		;PGA_1_GAIN_CR1(ACB00CR1)
                                        (0087) 	db		73h, 20h		;PGA_1_GAIN_CR2(ACB00CR2)
                                        (0088) 	db		70h, 00h		;PGA_1_GAIN_CR3(ACB00CR3)
                                        (0089) ;  Instance name PGA_2, User Module PGA
                                        (0090) ;       Instance name PGA_2, Block Name GAIN(ACB01)
                                        (0091) 	db		75h, feh		;PGA_2_GAIN_CR0(ACB01CR0)
                                        (0092) 	db		76h, 21h		;PGA_2_GAIN_CR1(ACB01CR1)
                                        (0093) 	db		77h, 20h		;PGA_2_GAIN_CR2(ACB01CR2)
                                        (0094) 	db		74h, 00h		;PGA_2_GAIN_CR3(ACB01CR3)
                                        (0095) ;  Instance name PGA_3, User Module PGA
                                        (0096) ;       Instance name PGA_3, Block Name GAIN(ACB02)
                                        (0097) 	db		79h, feh		;PGA_3_GAIN_CR0(ACB02CR0)
                                        (0098) 	db		7ah, 21h		;PGA_3_GAIN_CR1(ACB02CR1)
                                        (0099) 	db		7bh, 20h		;PGA_3_GAIN_CR2(ACB02CR2)
                                        (0100) 	db		78h, 00h		;PGA_3_GAIN_CR3(ACB02CR3)
                                        (0101) ;  Instance name PGA_4, User Module PGA
                                        (0102) ;       Instance name PGA_4, Block Name GAIN(ACB03)
                                        (0103) 	db		7dh, feh		;PGA_4_GAIN_CR0(ACB03CR0)
                                        (0104) 	db		7eh, 21h		;PGA_4_GAIN_CR1(ACB03CR1)
                                        (0105) 	db		7fh, 20h		;PGA_4_GAIN_CR2(ACB03CR2)
                                        (0106) 	db		7ch, 00h		;PGA_4_GAIN_CR3(ACB03CR3)
                                        (0107) ;  Instance name TX8, User Module TX8
                                        (0108) ;       Instance name TX8, Block Name TX8(DCB32)
                                        (0109) 	db		5bh, 00h		;TX8_CONTROL_REG  (DCB32CR0)
                                        (0110) 	db		59h, 00h		;TX8_TX_BUFFER_REG(DCB32DR1)
                                        (0111) 	db		5ah, 00h		;TX8_(DCB32DR2)
                                        (0112) ;  Instance name Timer16_1, User Module Timer16
                                        (0113) ;       Instance name Timer16_1, Block Name TIMER16_LSB(DBB30)
                                        (0114) 	db		53h, 00h		;Timer16_1_CONTROL_LSB_REG(DBB30CR0)
                                        (0115) 	db		51h, 00h		;Timer16_1_PERIOD_LSB_REG(DBB30DR1)
                                        (0116) 	db		52h, 00h		;Timer16_1_COMPARE_LSB_REG(DBB30DR2)
                                        (0117) ;       Instance name Timer16_1, Block Name TIMER16_MSB(DBB31)
                                        (0118) 	db		57h, 04h		;Timer16_1_CONTROL_MSB_REG(DBB31CR0)
                                        (0119) 	db		55h, 00h		;Timer16_1_PERIOD_MSB_REG(DBB31DR1)
                                        (0120) 	db		56h, 00h		;Timer16_1_COMPARE_MSB_REG(DBB31DR2)
                                        (0121) ;  Global Register values Bank 0
                                        (0122) 	db		60h, 94h		; AnalogColumnInputSelect register (AMX_IN)
                                        (0123) 	db		66h, 00h		; AnalogComparatorControl1 register (CMP_CR1)
                                        (0124) 	db		63h, 05h		; AnalogReferenceControl register (ARF_CR)
                                        (0125) 	db		65h, 00h		; AnalogSyncControl register (ASY_CR)
                                        (0126) 	db		e6h, 00h		; DecimatorControl_0 register (DEC_CR0)
                                        (0127) 	db		e7h, 00h		; DecimatorControl_1 register (DEC_CR1)
                                        (0128) 	db		d6h, 00h		; I2CConfig register (I2C_CFG)
                                        (0129) 	db		b0h, 00h		; Row_0_InputMux register (RDI0RI)
                                        (0130) 	db		b1h, 00h		; Row_0_InputSync register (RDI0SYN)
                                        (0131) 	db		b2h, 00h		; Row_0_LogicInputAMux register (RDI0IS)
                                        (0132) 	db		b3h, 33h		; Row_0_LogicSelect_0 register (RDI0LT0)
                                        (0133) 	db		b4h, 33h		; Row_0_LogicSelect_1 register (RDI0LT1)
                                        (0134) 	db		b5h, 00h		; Row_0_OutputDrive_0 register (RDI0SRO0)
                                        (0135) 	db		b6h, 00h		; Row_0_OutputDrive_1 register (RDI0SRO1)
                                        (0136) 	db		b8h, 55h		; Row_1_InputMux register (RDI1RI)
                                        (0137) 	db		b9h, 00h		; Row_1_InputSync register (RDI1SYN)
                                        (0138) 	db		bah, 10h		; Row_1_LogicInputAMux register (RDI1IS)
                                        (0139) 	db		bbh, 33h		; Row_1_LogicSelect_0 register (RDI1LT0)
                                        (0140) 	db		bch, 33h		; Row_1_LogicSelect_1 register (RDI1LT1)
                                        (0141) 	db		bdh, 00h		; Row_1_OutputDrive_0 register (RDI1SRO0)
                                        (0142) 	db		beh, 00h		; Row_1_OutputDrive_1 register (RDI1SRO1)
                                        (0143) 	db		c0h, 00h		; Row_2_InputMux register (RDI2RI)
                                        (0144) 	db		c1h, 00h		; Row_2_InputSync register (RDI2SYN)
                                        (0145) 	db		c2h, 20h		; Row_2_LogicInputAMux register (RDI2IS)
                                        (0146) 	db		c3h, 33h		; Row_2_LogicSelect_0 register (RDI2LT0)
                                        (0147) 	db		c4h, 33h		; Row_2_LogicSelect_1 register (RDI3LT1)
                                        (0148) 	db		c5h, 00h		; Row_2_OutputDrive_0 register (RDI2SRO0)
                                        (0149) 	db		c6h, 00h		; Row_2_OutputDrive_1 register (RDI2SRO1)
                                        (0150) 	db		c8h, 55h		; Row_3_InputMux register (RDI3RI)
                                        (0151) 	db		c9h, 00h		; Row_3_InputSync register (RDI3SYN)
                                        (0152) 	db		cah, 30h		; Row_3_LogicInputAMux register (RDI3IS)
                                        (0153) 	db		cbh, 33h		; Row_3_LogicSelect_0 register (RDI3LT0)
                                        (0154) 	db		cch, 33h		; Row_3_LogicSelect_1 register (RDI3LT1)
                                        (0155) 	db		cdh, 01h		; Row_3_OutputDrive_0 register (RDI3SRO0)
                                        (0156) 	db		ceh, 00h		; Row_3_OutputDrive_1 register (RDI3SRO1)
                                        (0157) 	db		6ch, 00h		; TMP_DR0 register (TMP_DR0)
                                        (0158) 	db		6dh, 00h		; TMP_DR1 register (TMP_DR1)
                                        (0159) 	db		6eh, 00h		; TMP_DR2 register (TMP_DR2)
                                        (0160) 	db		6fh, 00h		; TMP_DR3 register (TMP_DR3)
                                        (0161) 	db		ffh
                                        (0162) LoadConfigTBL_box_slave_Bank1:
                                        (0163) ;  Instance name ADCINCVR_1, User Module ADCINCVR
                                        (0164) ;       Instance name ADCINCVR_1, Block Name ADC(ASC10)
                                        (0165) ;       Instance name ADCINCVR_1, Block Name CNT(DBB00)
                                        (0166) 	db		20h, 21h		;ADCINCVR_1_fCounterFN      (DBB00FN)
                                        (0167) 	db		21h, 45h		;ADCINCVR_1_fCounterSL      (DBB00IN)
                                        (0168) 	db		22h, 40h		;ADCINCVR_1_fCounterOS      (DBB00OU)
                                        (0169) ;       Instance name ADCINCVR_1, Block Name PWM16_LSB(DBB01)
                                        (0170) 	db		24h, 01h		;ADCINCVR_1_bfPWM_LSB_FN    (DBB01FN)
                                        (0171) 	db		25h, 15h		;ADCINCVR_1_(DBB01IN)
                                        (0172) 	db		26h, 40h		;ADCINCVR_1_(DBB01OU)
                                        (0173) ;       Instance name ADCINCVR_1, Block Name PWM16_MSB(DCB02)
                                        (0174) 	db		28h, 21h		;ADCINCVR_1_bfPWM_MSB_FN    (DCB02FN)
                                        (0175) 	db		29h, 35h		;ADCINCVR_1_(DCB02IN)
                                        (0176) 	db		2ah, 40h		;ADCINCVR_1_(DCB02OU)
                                        (0177) ;  Instance name ADCINCVR_2, User Module ADCINCVR
                                        (0178) ;       Instance name ADCINCVR_2, Block Name ADC(ASD11)
                                        (0179) ;       Instance name ADCINCVR_2, Block Name CNT(DCB03)
                                        (0180) 	db		2ch, 21h		;ADCINCVR_2_fCounterFN      (DCB03FN)
                                        (0181) 	db		2dh, 55h		;ADCINCVR_2_fCounterSL      (DCB03IN)
                                        (0182) 	db		2eh, 40h		;ADCINCVR_2_fCounterOS      (DCB03OU)
                                        (0183) ;       Instance name ADCINCVR_2, Block Name PWM16_LSB(DCB12)
                                        (0184) 	db		38h, 01h		;ADCINCVR_2_bfPWM_LSB_FN    (DCB12FN)
                                        (0185) 	db		39h, 15h		;ADCINCVR_2_(DCB12IN)
                                        (0186) 	db		3ah, 40h		;ADCINCVR_2_(DCB12OU)
                                        (0187) ;       Instance name ADCINCVR_2, Block Name PWM16_MSB(DCB13)
                                        (0188) 	db		3ch, 21h		;ADCINCVR_2_bfPWM_MSB_FN    (DCB13FN)
                                        (0189) 	db		3dh, 35h		;ADCINCVR_2_(DCB13IN)
                                        (0190) 	db		3eh, 40h		;ADCINCVR_2_(DCB13OU)
                                        (0191) ;  Instance name ADCINCVR_3, User Module ADCINCVR
                                        (0192) ;       Instance name ADCINCVR_3, Block Name ADC(ASC12)
                                        (0193) ;       Instance name ADCINCVR_3, Block Name CNT(DBB10)
                                        (0194) 	db		30h, 21h		;ADCINCVR_3_fCounterFN      (DBB10FN)
                                        (0195) 	db		31h, 65h		;ADCINCVR_3_fCounterSL      (DBB10IN)
                                        (0196) 	db		32h, 40h		;ADCINCVR_3_fCounterOS      (DBB10OU)
                                        (0197) ;       Instance name ADCINCVR_3, Block Name PWM16_LSB(DBB20)
                                        (0198) 	db		40h, 01h		;ADCINCVR_3_bfPWM_LSB_FN    (DBB20FN)
                                        (0199) 	db		41h, 15h		;ADCINCVR_3_(DBA20IN)
                                        (0200) 	db		42h, 40h		;ADCINCVR_3_(DBA20OU)
                                        (0201) ;       Instance name ADCINCVR_3, Block Name PWM16_MSB(DBB21)
                                        (0202) 	db		44h, 21h		;ADCINCVR_3_bfPWM_MSB_FN    (DBB21FN)
                                        (0203) 	db		45h, 35h		;ADCINCVR_3_(DBB21IN)
                                        (0204) 	db		46h, 40h		;ADCINCVR_3_(DBB21OU)
                                        (0205) ;  Instance name ADCINCVR_4, User Module ADCINCVR
                                        (0206) ;       Instance name ADCINCVR_4, Block Name ADC(ASD13)
                                        (0207) ;       Instance name ADCINCVR_4, Block Name CNT(DBB11)
                                        (0208) 	db		34h, 21h		;ADCINCVR_4_fCounterFN      (DBB11FN)
                                        (0209) 	db		35h, 75h		;ADCINCVR_4_fCounterSL      (DBB11IN)
                                        (0210) 	db		36h, 40h		;ADCINCVR_4_fCounterOS      (DBB11OU)
                                        (0211) ;       Instance name ADCINCVR_4, Block Name PWM16_LSB(DCB22)
                                        (0212) 	db		48h, 01h		;ADCINCVR_4_bfPWM_LSB_FN    (DCB22FN)
                                        (0213) 	db		49h, 15h		;ADCINCVR_4_(DCB22IN)
                                        (0214) 	db		4ah, 40h		;ADCINCVR_4_(DCB22OU)
                                        (0215) ;       Instance name ADCINCVR_4, Block Name PWM16_MSB(DCB23)
                                        (0216) 	db		4ch, 21h		;ADCINCVR_4_bfPWM_MSB_FN    (DCB23FN)
                                        (0217) 	db		4dh, 35h		;ADCINCVR_4_(DCB23IN)
                                        (0218) 	db		4eh, 40h		;ADCINCVR_4_(DCB23OU)
                                        (0219) ;  Instance name I2CHW, User Module I2CHW
                                        (0220) ;  Instance name PGA_1, User Module PGA
                                        (0221) ;       Instance name PGA_1, Block Name GAIN(ACB00)
                                        (0222) ;  Instance name PGA_2, User Module PGA
                                        (0223) ;       Instance name PGA_2, Block Name GAIN(ACB01)
                                        (0224) ;  Instance name PGA_3, User Module PGA
                                        (0225) ;       Instance name PGA_3, Block Name GAIN(ACB02)
                                        (0226) ;  Instance name PGA_4, User Module PGA
                                        (0227) ;       Instance name PGA_4, Block Name GAIN(ACB03)
                                        (0228) ;  Instance name TX8, User Module TX8
                                        (0229) ;       Instance name TX8, Block Name TX8(DCB32)
                                        (0230) 	db		58h, 1dh		;TX8_FUNC_REG     (DCB32FN)
                                        (0231) 	db		59h, 01h		;TX8_INPUT_REG    (DCB32IN)
                                        (0232) 	db		5ah, 44h		;TX8_OUTPUT_REG   (DCB32OU)
                                        (0233) ;  Instance name Timer16_1, User Module Timer16
                                        (0234) ;       Instance name Timer16_1, Block Name TIMER16_LSB(DBB30)
                                        (0235) 	db		50h, 00h		;Timer16_1_FUNC_LSB_REG(DBB30FN)
                                        (0236) 	db		51h, 00h		;Timer16_1_INPUT_LSB_REG(DBB30IN)
                                        (0237) 	db		52h, 00h		;Timer16_1_OUTPUT_LSB_REG(DBB30OU)
                                        (0238) ;       Instance name Timer16_1, Block Name TIMER16_MSB(DBB31)
                                        (0239) 	db		54h, 20h		;Timer16_1_FUNC_MSB_REG(DBB31FN)
                                        (0240) 	db		55h, 30h		;Timer16_1_INPUT_MSB_REG(DBB31IN)
                                        (0241) 	db		56h, 00h		;Timer16_1_OUTPUT_MSB_REG(DBB31OU)
                                        (0242) ;  Global Register values Bank 1
                                        (0243) 	db		61h, 00h		; AnalogClockSelect1 register (CLK_CR1)
                                        (0244) 	db		69h, 00h		; AnalogClockSelect2 register (CLK_CR2)
                                        (0245) 	db		60h, 00h		; AnalogColumnClockSelect register (CLK_CR0)
                                        (0246) 	db		62h, 00h		; AnalogIOControl_0 register (ABF_CR0)
                                        (0247) 	db		67h, 33h		; AnalogLUTControl0 register (ALT_CR0)
                                        (0248) 	db		68h, 33h		; AnalogLUTControl1 register (ALT_CR1)
                                        (0249) 	db		63h, 00h		; AnalogModulatorControl_0 register (AMD_CR0)
                                        (0250) 	db		66h, 00h		; AnalogModulatorControl_1 register (AMD_CR1)
                                        (0251) 	db		d1h, 00h		; GlobalDigitalInterconnect_Drive_Even_Input register (GDI_E_IN)
                                        (0252) 	db		d3h, 00h		; GlobalDigitalInterconnect_Drive_Even_Output register (GDI_E_OU)
                                        (0253) 	db		d0h, 00h		; GlobalDigitalInterconnect_Drive_Odd_Input register (GDI_O_IN)
                                        (0254) 	db		d2h, 00h		; GlobalDigitalInterconnect_Drive_Odd_Output register (GDI_O_OU)
                                        (0255) 	db		e1h, bfh		; OscillatorControl_1 register (OSC_CR1)
                                        (0256) 	db		e2h, 00h		; OscillatorControl_2 register (OSC_CR2)
                                        (0257) 	db		dfh, 19h		; OscillatorControl_3 register (OSC_CR3)
                                        (0258) 	db		deh, 01h		; OscillatorControl_4 register (OSC_CR4)
                                        (0259) 	db		ddh, 00h		; OscillatorGlobalBusEnableControl register (OSC_GO_EN)
                                        (0260) 	db		e7h, 00h		; Type2Decimator_Control register (DEC_CR2)
                                        (0261) 	db		ffh
                                        (0262) LoadConfigTBL_box_slave_Ordered:
                                        (0263) ;  Ordered Global Register values

(0264) 	M8C_SetBank1
0309: 10       PUSH  X                  
030A: 62 00 01 MOV   REG[0x0],0x1       (0265) 	mov	reg[00h], 01h		; Port_0_DriveMode_0 register (PRT0DM0)
030D: 62 01 FE MOV   REG[0x1],0xFE      (0266) 	mov	reg[01h], feh		; Port_0_DriveMode_1 register (PRT0DM1)
0310: 70 EF    AND   F,0xEF             (0267) 	M8C_SetBank0
0312: 62 03 FE MOV   REG[0x3],0xFE      (0268) 	mov	reg[03h], feh		; Port_0_DriveMode_2 register (PRT0DM2)
0315: 62 02 01 MOV   REG[0x2],0x1       (0269) 	mov	reg[02h], 01h		; Port_0_GlobalSelect register (PRT0GS)
0318: 71 10    OR    F,0x10             (0270) 	M8C_SetBank1
031A: 62 02 00 MOV   REG[0x2],0x0       (0271) 	mov	reg[02h], 00h		; Port_0_IntCtrl_0 register (PRT0IC0)
031D: 62 03 00 MOV   REG[0x3],0x0       (0272) 	mov	reg[03h], 00h		; Port_0_IntCtrl_1 register (PRT0IC1)
0320: 70 EF    AND   F,0xEF             (0273) 	M8C_SetBank0
0322: 62 01 00 MOV   REG[0x1],0x0       (0274) 	mov	reg[01h], 00h		; Port_0_IntEn register (PRT0IE)
0325: 71 10    OR    F,0x10             (0275) 	M8C_SetBank1
0327: 62 04 A0 MOV   REG[0x4],0xA0      (0276) 	mov	reg[04h], a0h		; Port_1_DriveMode_0 register (PRT1DM0)
032A: 62 05 FF MOV   REG[0x5],0xFF      (0277) 	mov	reg[05h], ffh		; Port_1_DriveMode_1 register (PRT1DM1)
032D: 70 EF    AND   F,0xEF             (0278) 	M8C_SetBank0
032F: 62 07 FF MOV   REG[0x7],0xFF      (0279) 	mov	reg[07h], ffh		; Port_1_DriveMode_2 register (PRT1DM2)
0332: 62 06 00 MOV   REG[0x6],0x0       (0280) 	mov	reg[06h], 00h		; Port_1_GlobalSelect register (PRT1GS)
0335: 71 10    OR    F,0x10             (0281) 	M8C_SetBank1
0337: 62 06 00 MOV   REG[0x6],0x0       (0282) 	mov	reg[06h], 00h		; Port_1_IntCtrl_0 register (PRT1IC0)
033A: 62 07 00 MOV   REG[0x7],0x0       (0283) 	mov	reg[07h], 00h		; Port_1_IntCtrl_1 register (PRT1IC1)
033D: 70 EF    AND   F,0xEF             (0284) 	M8C_SetBank0
033F: 62 05 00 MOV   REG[0x5],0x0       (0285) 	mov	reg[05h], 00h		; Port_1_IntEn register (PRT1IE)
0342: 71 10    OR    F,0x10             (0286) 	M8C_SetBank1
0344: 62 08 05 MOV   REG[0x8],0x5       (0287) 	mov	reg[08h], 05h		; Port_2_DriveMode_0 register (PRT2DM0)
0347: 62 09 FE MOV   REG[0x9],0xFE      (0288) 	mov	reg[09h], feh		; Port_2_DriveMode_1 register (PRT2DM1)
034A: 70 EF    AND   F,0xEF             (0289) 	M8C_SetBank0
034C: 62 0B FA MOV   REG[0xB],0xFA      (0290) 	mov	reg[0bh], fah		; Port_2_DriveMode_2 register (PRT2DM2)
034F: 62 0A 00 MOV   REG[0xA],0x0       (0291) 	mov	reg[0ah], 00h		; Port_2_GlobalSelect register (PRT2GS)
0352: 71 10    OR    F,0x10             (0292) 	M8C_SetBank1
0354: 62 0A 04 MOV   REG[0xA],0x4       (0293) 	mov	reg[0ah], 04h		; Port_2_IntCtrl_0 register (PRT2IC0)
0357: 62 0B 04 MOV   REG[0xB],0x4       (0294) 	mov	reg[0bh], 04h		; Port_2_IntCtrl_1 register (PRT2IC1)
035A: 70 EF    AND   F,0xEF             (0295) 	M8C_SetBank0
035C: 62 09 04 MOV   REG[0x9],0x4       (0296) 	mov	reg[09h], 04h		; Port_2_IntEn register (PRT2IE)
035F: 71 10    OR    F,0x10             (0297) 	M8C_SetBank1
0361: 62 0C 00 MOV   REG[0xC],0x0       (0298) 	mov	reg[0ch], 00h		; Port_3_DriveMode_0 register (PRT3DM0)
0364: 62 0D 00 MOV   REG[0xD],0x0       (0299) 	mov	reg[0dh], 00h		; Port_3_DriveMode_1 register (PRT3DM1)
0367: 70 EF    AND   F,0xEF             (0300) 	M8C_SetBank0
0369: 62 0F 00 MOV   REG[0xF],0x0       (0301) 	mov	reg[0fh], 00h		; Port_3_DriveMode_2 register (PRT3DM2)
036C: 62 0E 00 MOV   REG[0xE],0x0       (0302) 	mov	reg[0eh], 00h		; Port_3_GlobalSelect register (PRT3GS)
036F: 71 10    OR    F,0x10             (0303) 	M8C_SetBank1
0371: 62 0E 00 MOV   REG[0xE],0x0       (0304) 	mov	reg[0eh], 00h		; Port_3_IntCtrl_0 register (PRT3IC0)
0374: 62 0F 00 MOV   REG[0xF],0x0       (0305) 	mov	reg[0fh], 00h		; Port_3_IntCtrl_1 register (PRT3IC1)
0377: 70 EF    AND   F,0xEF             (0306) 	M8C_SetBank0
0379: 62 0D 00 MOV   REG[0xD],0x0       (0307) 	mov	reg[0dh], 00h		; Port_3_IntEn register (PRT3IE)
037C: 71 10    OR    F,0x10             (0308) 	M8C_SetBank1
037E: 62 10 00 MOV   REG[0x10],0x0      (0309) 	mov	reg[10h], 00h		; Port_4_DriveMode_0 register (PRT4DM0)
0381: 62 11 00 MOV   REG[0x11],0x0      (0310) 	mov	reg[11h], 00h		; Port_4_DriveMode_1 register (PRT4DM1)
0384: 70 EF    AND   F,0xEF             (0311) 	M8C_SetBank0
0386: 62 13 00 MOV   REG[0x13],0x0      (0312) 	mov	reg[13h], 00h		; Port_4_DriveMode_2 register (PRT4DM2)
0389: 62 12 00 MOV   REG[0x12],0x0      (0313) 	mov	reg[12h], 00h		; Port_4_GlobalSelect register (PRT4GS)
038C: 71 10    OR    F,0x10             (0314) 	M8C_SetBank1
038E: 62 12 00 MOV   REG[0x12],0x0      (0315) 	mov	reg[12h], 00h		; Port_4_IntCtrl_0 register (PRT4IC0)
0391: 62 13 00 MOV   REG[0x13],0x0      (0316) 	mov	reg[13h], 00h		; Port_4_IntCtrl_1 register (PRT4IC1)
0394: 70 EF    AND   F,0xEF             (0317) 	M8C_SetBank0
0396: 62 11 00 MOV   REG[0x11],0x0      (0318) 	mov	reg[11h], 00h		; Port_4_IntEn register (PRT4IE)
0399: 71 10    OR    F,0x10             (0319) 	M8C_SetBank1
039B: 62 14 00 MOV   REG[0x14],0x0      (0320) 	mov	reg[14h], 00h		; Port_5_DriveMode_0 register (PRT5DM0)
039E: 62 15 00 MOV   REG[0x15],0x0      (0321) 	mov	reg[15h], 00h		; Port_5_DriveMode_1 register (PRT5DM1)
03A1: 70 EF    AND   F,0xEF             (0322) 	M8C_SetBank0
03A3: 62 17 00 MOV   REG[0x17],0x0      (0323) 	mov	reg[17h], 00h		; Port_5_DriveMode_2 register (PRT5DM2)
03A6: 62 16 00 MOV   REG[0x16],0x0      (0324) 	mov	reg[16h], 00h		; Port_5_GlobalSelect register (PRT5GS)
03A9: 71 10    OR    F,0x10             (0325) 	M8C_SetBank1
03AB: 62 16 00 MOV   REG[0x16],0x0      (0326) 	mov	reg[16h], 00h		; Port_5_IntCtrl_0 register (PRT5IC0)
03AE: 62 17 00 MOV   REG[0x17],0x0      (0327) 	mov	reg[17h], 00h		; Port_5_IntCtrl_1 register (PRT5IC1)
03B1: 70 EF    AND   F,0xEF             (0328) 	M8C_SetBank0
03B3: 62 15 00 MOV   REG[0x15],0x0      (0329) 	mov	reg[15h], 00h		; Port_5_IntEn register (PRT5IE)
03B6: 71 10    OR    F,0x10             (0330) 	M8C_SetBank1
03B8: 62 18 00 MOV   REG[0x18],0x0      (0331) 	mov	reg[18h], 00h		; Port_6_DriveMode_0 register (PRT6DM0)
03BB: 62 19 00 MOV   REG[0x19],0x0      (0332) 	mov	reg[19h], 00h		; Port_6_DriveMode_1 register (PRT6DM1)
03BE: 70 EF    AND   F,0xEF             (0333) 	M8C_SetBank0
03C0: 62 1B 00 MOV   REG[0x1B],0x0      (0334) 	mov	reg[1bh], 00h		; Port_6_DriveMode_2 register (PRT6DM2)
03C3: 62 1A 00 MOV   REG[0x1A],0x0      (0335) 	mov	reg[1ah], 00h		; Port_6_GlobalSelect register (PRT6GS)
03C6: 71 10    OR    F,0x10             (0336) 	M8C_SetBank1
03C8: 62 1A 00 MOV   REG[0x1A],0x0      (0337) 	mov	reg[1ah], 00h		; Port_6_IntCtrl_0 register (PRT6IC0)
03CB: 62 1B 00 MOV   REG[0x1B],0x0      (0338) 	mov	reg[1bh], 00h		; Port_6_IntCtrl_1 register (PRT6IC1)
03CE: 70 EF    AND   F,0xEF             (0339) 	M8C_SetBank0
03D0: 62 19 00 MOV   REG[0x19],0x0      (0340) 	mov	reg[19h], 00h		; Port_6_IntEn register (PRT6IE)
03D3: 71 10    OR    F,0x10             (0341) 	M8C_SetBank1
03D5: 62 1C 00 MOV   REG[0x1C],0x0      (0342) 	mov	reg[1ch], 00h		; Port_7_DriveMode_0 register (PRT7DM0)
03D8: 62 1D 00 MOV   REG[0x1D],0x0      (0343) 	mov	reg[1dh], 00h		; Port_7_DriveMode_1 register (PRT7DM1)
03DB: 70 EF    AND   F,0xEF             (0344) 	M8C_SetBank0
03DD: 62 1F 00 MOV   REG[0x1F],0x0      (0345) 	mov	reg[1fh], 00h		; Port_7_DriveMode_2 register (PRT7DM2)
03E0: 62 1E 00 MOV   REG[0x1E],0x0      (0346) 	mov	reg[1eh], 00h		; Port_7_GlobalSelect register (PRT7GS)
03E3: 71 10    OR    F,0x10             (0347) 	M8C_SetBank1
03E5: 62 1E 00 MOV   REG[0x1E],0x0      (0348) 	mov	reg[1eh], 00h		; Port_7_IntCtrl_0 register (PRT7IC0)
03E8: 62 1F 00 MOV   REG[0x1F],0x0      (0349) 	mov	reg[1fh], 00h		; Port_7_IntCtrl_1 register (PRT7IC1)
03EB: 70 EF    AND   F,0xEF             (0350) 	M8C_SetBank0
03ED: 62 1D 00 MOV   REG[0x1D],0x0      (0351) 	mov	reg[1dh], 00h		; Port_7_IntEn register (PRT7IE)
03F0: 70 EF    AND   F,0xEF             (0352) 	M8C_SetBank0
03F2: 7F       RET                      (0353) 	ret
(0354) 
(0355) 
(0356) ; PSoC Configuration file trailer PsocConfig.asm
FILE: lib\psocconfig.asm
                                        (0001) ; Generated by PSoC Designer 5.0.1127.0
                                        (0002) ;
                                        (0003) ;==========================================================================
                                        (0004) ;  PSoCConfig.asm
                                        (0005) ;  @PSOC_VERSION
                                        (0006) ;
                                        (0007) ;  Version: 0.85
                                        (0008) ;  Revised: June 22, 2004
                                        (0009) ;  Copyright (c) Cypress Semiconductor 2009. All Rights Reserved.
                                        (0010) ;
                                        (0011) ;  This file is generated by the Device Editor on Application Generation.
                                        (0012) ;  It contains code which loads the configuration data table generated in
                                        (0013) ;  the file PSoCConfigTBL.asm
                                        (0014) ;
                                        (0015) ;  DO NOT EDIT THIS FILE MANUALLY, AS IT IS OVERWRITTEN!!!
                                        (0016) ;  Edits to this file will not be preserved.
                                        (0017) ;==========================================================================
                                        (0018) ;
                                        (0019) include "m8c.inc"
                                        (0020) include "memory.inc"
                                        (0021) include "GlobalParams.inc"
                                        (0022) 
                                        (0023) export LoadConfigInit
                                        (0024) export _LoadConfigInit
                                        (0025) export LoadConfig_box_slave
                                        (0026) export _LoadConfig_box_slave
                                        (0027) 
                                        (0028) export NO_SHADOW
                                        (0029) export _NO_SHADOW
                                        (0030) 
                                        (0031) FLAG_CFG_MASK:      equ 10h         ;M8C flag register REG address bit mask
                                        (0032) END_CONFIG_TABLE:   equ ffh         ;end of config table indicator
                                        (0033) 
                                        (0034) AREA psoc_config(rom, rel)
                                        (0035) 
                                        (0036) ;---------------------------------------------------------------------------
                                        (0037) ; LoadConfigInit - Establish the start-up configuration (except for a few
                                        (0038) ;                  parameters handled by boot code, like CPU speed). This
                                        (0039) ;                  function can be called from user code, but typically it
                                        (0040) ;                  is only called from boot.
                                        (0041) ;
                                        (0042) ;       INPUTS: None.
                                        (0043) ;      RETURNS: Nothing.
                                        (0044) ; SIDE EFFECTS: Registers are volatile: the A and X registers can be modified!
                                        (0045) ;               In the large memory model currently only the page
                                        (0046) ;               pointer registers listed below are modified.  This does
                                        (0047) ;               not guarantee that in future implementations of this
                                        (0048) ;               function other page pointer registers will not be
                                        (0049) ;               modified.
                                        (0050) ;          
                                        (0051) ;               Page Pointer Registers Modified: 
                                        (0052) ;               CUR_PP
                                        (0053) ;
                                        (0054) _LoadConfigInit:
                                        (0055)  LoadConfigInit:
                                        (0056)     RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0057)     

(0058) 	lcall	LoadConfig_box_slave
03F6: 03 FC    ADD   A,[X-4]            
03F8: 7C 03 08 LCALL 0x0308             (0059) 	lcall	LoadConfigTBL_box_slave_Ordered
                                        (0060) 
                                        (0061) 
                                        (0062)     RAM_EPILOGUE RAM_USE_CLASS_4
03FB: 7F       RET                      (0063)     ret
                                        (0064) 
                                        (0065) ;---------------------------------------------------------------------------
                                        (0066) ; Load Configuration box_slave
                                        (0067) ;
                                        (0068) ;    Load configuration registers for box_slave.
                                        (0069) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
                                        (0070) ;
                                        (0071) ;       INPUTS: None.
                                        (0072) ;      RETURNS: Nothing.
                                        (0073) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
                                        (0074) ;               modified as may the Page Pointer registers!
                                        (0075) ;               In the large memory model currently only the page
                                        (0076) ;               pointer registers listed below are modified.  This does
                                        (0077) ;               not guarantee that in future implementations of this
                                        (0078) ;               function other page pointer registers will not be
                                        (0079) ;               modified.
                                        (0080) ;          
                                        (0081) ;               Page Pointer Registers Modified: 
                                        (0082) ;               CUR_PP
                                        (0083) ;
                                        (0084) _LoadConfig_box_slave:
                                        (0085)  LoadConfig_box_slave:
                                        (0086)     RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0087) 
03FC: 10       PUSH  X                  (0088) 	push	x
03FD: 70 EF    AND   F,0xEF             (0089)     M8C_SetBank0                    ; Force bank 0
03FF: 50 00    MOV   A,0x0              (0090)     mov     a, 0                    ; Specify bank 0
0401: 67       ASR   A                  (0091)     asr     a                       ; Store in carry flag
                                        (0092)                                     ; Load bank 0 table:
0402: 50 01    MOV   A,0x1              (0093)     mov     A, >LoadConfigTBL_box_slave_Bank0
0404: 57 A0    MOV   X,0xA0             (0094)     mov     X, <LoadConfigTBL_box_slave_Bank0
0406: 7C 04 17 LCALL 0x0417             (0095)     lcall   LoadConfig              ; Load the bank 0 values
                                        (0096) 
0409: 50 01    MOV   A,0x1              (0097)     mov     a, 1                    ; Specify bank 1
040B: 67       ASR   A                  (0098)     asr     a                       ; Store in carry flag
                                        (0099)                                     ; Load bank 1 table:
040C: 50 02    MOV   A,0x2              (0100)     mov     A, >LoadConfigTBL_box_slave_Bank1
040E: 57 89    MOV   X,0x89             (0101)     mov     X, <LoadConfigTBL_box_slave_Bank1
0410: 7C 04 17 LCALL 0x0417             (0102)     lcall   LoadConfig              ; Load the bank 1 values
                                        (0103) 
0413: 70 EF    AND   F,0xEF             (0104)     M8C_SetBank0                    ; Force return to bank 0
0415: 20       POP   X                  (0105) 	pop		x
                                        (0106) 
                                        (0107)     RAM_EPILOGUE RAM_USE_CLASS_4
0416: 7F       RET                      (0108)     ret
                                        (0109) 
                                        (0110) 
                                        (0111) 
                                        (0112) 
                                        (0113) ;---------------------------------------------------------------------------
                                        (0114) ; LoadConfig - Set IO registers as specified in ROM table of (address,value)
                                        (0115) ;              pairs. Terminate on address=0xFF.
                                        (0116) ;
                                        (0117) ;  INPUTS:  [A,X] points to the table to be loaded
                                        (0118) ;           Flag Register Carry bit encodes the Register Bank
                                        (0119) ;           (Carry=0 => Bank 0; Carry=1 => Bank 1)
                                        (0120) ;
                                        (0121) ;  RETURNS: nothing.
                                        (0122) ;
                                        (0123) ;  STACK FRAME:  X-4 I/O Bank 0/1 indicator
                                        (0124) ;                X-3 Temporary store for register address
                                        (0125) ;                X-2 LSB of config table address
                                        (0126) ;                X-1 MSB of config table address
                                        (0127) ;
                                        (0128) LoadConfig:
                                        (0129)     RAM_PROLOGUE RAM_USE_CLASS_2
0417: 38 02    ADD   SP,0x2             (0130)     add     SP, 2                   ; Set up local vars
0419: 10       PUSH  X                  (0131)     push    X                       ; Save config table address on stack
041A: 08       PUSH  A                  (0132)     push    A
041B: 4F       MOV   X,SP               (0133)     mov     X, SP
041C: 56 FC 00 MOV   [X-4],0x0          (0134)     mov     [X-4], 0                ; Set default Destination to Bank 0
041F: D0 04    JNC   0x0424             (0135)     jnc     .BankSelectSaved        ; Carry says Bank 0 is OK
0421: 56 FC 01 MOV   [X-4],0x1          (0136)     mov     [X-4], 1                ; No Carry: default to Bank 1
                                        (0137) .BankSelectSaved:
0424: 18       POP   A                  (0138)     pop     A
0425: 20       POP   X                  (0139)     pop     X
                                        (0140) 
                                        (0141) LoadConfigLp:
0426: 70 EF    AND   F,0xEF             (0142)     M8C_SetBank0                    ; Switch to bank 0
0428: 62 E3 00 MOV   REG[0xE3],0x0      (0143)     M8C_ClearWDT                    ; Clear the watchdog for long inits
042B: 10       PUSH  X                  (0144)     push    X                       ; Preserve the config table address
042C: 08       PUSH  A                  (0145)     push    A
042D: 28       ROMX                     (0146)     romx                            ; Load register address from table
042E: 39 FF    CMP   A,0xFF             (0147)     cmp     A, END_CONFIG_TABLE     ; End of table?
0430: A0 1F    JZ    0x0450             (0148)     jz      EndLoadConfig           ;   Yes, go wrap it up
0432: 4F       MOV   X,SP               (0149)     mov     X, SP                   ;
0433: 48 FC 01 TST   [X-4],0x1          (0150)     tst     [X-4], 1                ; Loading IO Bank 1?
0436: A0 03    JZ    0x043A             (0151)     jz      .IOBankNowSet           ;    No, Bank 0 is fine
0438: 71 10    OR    F,0x10             (0152)     M8C_SetBank1                    ;   Yes, switch to Bank 1
                                        (0153) .IOBankNowSet:
043A: 54 FD    MOV   [X-3],A            (0154)     mov     [X-3], A                ; Stash the register address
043C: 18       POP   A                  (0155)     pop     A                       ; Retrieve the table address
043D: 20       POP   X                  (0156)     pop     X
043E: 75       INC   X                  (0157)     inc     X                       ; Advance to the data byte
043F: 09 00    ADC   A,0x0              (0158)     adc     A, 0
0441: 10       PUSH  X                  (0159)     push    X                       ; Save the config table address again
0442: 08       PUSH  A                  (0160)     push    A
0443: 28       ROMX                     (0161)     romx                            ; load config data from the table
0444: 4F       MOV   X,SP               (0162)     mov     X, SP                   ; retrieve the register address
0445: 59 FD    MOV   X,[X-3]            (0163)     mov     X, [X-3]
0447: 61 00    MOV   REG[X+0x0],A       (0164)     mov     reg[X], A               ; Configure the register
0449: 18       POP   A                  (0165)     pop     A                       ; retrieve the table address
044A: 20       POP   X                  (0166)     pop     X
044B: 75       INC   X                  (0167)     inc     X                       ; advance to next table entry
044C: 09 00    ADC   A,0x0              (0168)     adc     A, 0
044E: 8F D7    JMP   0x0426             (0169)     jmp     LoadConfigLp            ; loop to configure another register
                                        (0170) EndLoadConfig:
0450: 38 FC    ADD   SP,0xFC            (0171)     add     SP, -4
0452: 70 3F    AND   F,0x3F             
0454: 71 C0    OR    F,0xC0             (0172)     RAM_EPILOGUE RAM_USE_CLASS_2
0456: 7F       RET                      (0173)     ret
(0174) 
(0175) AREA InterruptRAM(ram, rel)
(0176) 
(0177) NO_SHADOW:
(0178) _NO_SHADOW:
FILE: lib\tx8int.asm
                                        (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: TX8INT.asm
                                        (0004) ;;   Version: 3.3, Updated on 2009/10/23 at 10:13:12
                                        (0005) ;;  Generated by PSoC Designer 5.0.1127.0
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION:  TX8 Interrupt Service Rountine.
                                        (0008) ;;-----------------------------------------------------------------------------
                                        (0009) ;;  Copyright (c) Cypress Semiconductor 2009. All Rights Reserved.
                                        (0010) ;;*****************************************************************************
                                        (0011) ;;*****************************************************************************
                                        (0012) 
                                        (0013) include "m8c.inc"
                                        (0014) include "memory.inc"
                                        (0015) include "TX8.inc"
                                        (0016) 
                                        (0017) 
                                        (0018) ;-----------------------------------------------
                                        (0019) ;  Global Symbols
                                        (0020) ;-----------------------------------------------
                                        (0021) export  _TX8_ISR
                                        (0022) 
                                        (0023) 
                                        (0024) AREA InterruptRAM (RAM,REL,CON)
                                        (0025) 
                                        (0026) ;@PSoC_UserCode_INIT@ (Do not change this line.)
                                        (0027) ;---------------------------------------------------
                                        (0028) ; Insert your custom declarations below this banner
                                        (0029) ;---------------------------------------------------
                                        (0030) 
                                        (0031) ;------------------------
                                        (0032) ; Includes
                                        (0033) ;------------------------
                                        (0034) 
                                        (0035) 	
                                        (0036) ;------------------------
                                        (0037) ;  Constant Definitions
                                        (0038) ;------------------------
                                        (0039) 
                                        (0040) 
                                        (0041) ;------------------------
                                        (0042) ; Variable Allocation
                                        (0043) ;------------------------
                                        (0044) 
                                        (0045) 
                                        (0046) ;---------------------------------------------------
                                        (0047) ; Insert your custom declarations above this banner
                                        (0048) ;---------------------------------------------------
                                        (0049) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0050) 
                                        (0051) 
                                        (0052) AREA UserModules (ROM, REL)
                                        (0053) 
                                        (0054) ;-----------------------------------------------------------------------------
                                        (0055) ;  FUNCTION NAME: _TX8_ISR
                                        (0056) ;
                                        (0057) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
                                        (0058) ;
                                        (0059) ;-----------------------------------------------------------------------------
                                        (0060) ;
                                        (0061) 
                                        (0062) _TX8_ISR:
                                        (0063) 
                                        (0064)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                        (0065)    ;---------------------------------------------------
                                        (0066)    ; Insert your custom code below this banner
                                        (0067)    ;---------------------------------------------------
                                        (0068)    ;   NOTE: interrupt service routines must preserve
                                        (0069)    ;   the values of the A and X CPU registers.
                                        (0070) 
                                        (0071)    ;---------------------------------------------------
                                        (0072)    ; Insert your custom code above this banner
                                        (0073)    ;---------------------------------------------------
                                        (0074)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0075) 
0457: 7E       RETI                     (0076)    reti
(0077) 
(0078) 
(0079) ; end of file TX8INT.asm
FILE: lib\timer16_1int.asm
                                        (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: Timer16_1INT.asm
                                        (0004) ;;   Version: 2.6, Updated on 2009/10/15 at 17:11:37
                                        (0005) ;;  Generated by PSoC Designer 5.0.1127.0
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: Timer16 Interrupt Service Routine
                                        (0008) ;;-----------------------------------------------------------------------------
                                        (0009) ;;  Copyright (c) Cypress Semiconductor 2009. All Rights Reserved.
                                        (0010) ;;*****************************************************************************
                                        (0011) ;;*****************************************************************************
                                        (0012) 
                                        (0013) include "m8c.inc"
                                        (0014) include "memory.inc"
                                        (0015) include "Timer16_1.inc"
                                        (0016) 
                                        (0017) 
                                        (0018) ;-----------------------------------------------
                                        (0019) ;  Global Symbols
                                        (0020) ;-----------------------------------------------
                                        (0021) export  _Timer16_1_ISR
                                        (0022) 
                                        (0023) 
                                        (0024) AREA InterruptRAM (RAM,REL,CON)
                                        (0025) 
                                        (0026) ;@PSoC_UserCode_INIT@ (Do not change this line.)
                                        (0027) ;---------------------------------------------------
                                        (0028) ; Insert your custom declarations below this banner
                                        (0029) ;---------------------------------------------------
                                        (0030) 
                                        (0031) ;------------------------
                                        (0032) ; Includes
                                        (0033) ;------------------------
                                        (0034) 
                                        (0035) 	
                                        (0036) ;------------------------
                                        (0037) ;  Constant Definitions
                                        (0038) ;------------------------
                                        (0039) 
                                        (0040) 
                                        (0041) ;------------------------
                                        (0042) ; Variable Allocation
                                        (0043) ;------------------------
                                        (0044) 
                                        (0045) 
                                        (0046) ;---------------------------------------------------
                                        (0047) ; Insert your custom declarations above this banner
                                        (0048) ;---------------------------------------------------
                                        (0049) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0050) 
                                        (0051) 
                                        (0052) AREA UserModules (ROM, REL)
                                        (0053) 
                                        (0054) ;-----------------------------------------------------------------------------
                                        (0055) ;  FUNCTION NAME: _Timer16_1_ISR
                                        (0056) ;
                                        (0057) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
                                        (0058) ;
                                        (0059) ;-----------------------------------------------------------------------------
                                        (0060) ;
                                        (0061) 
                                        (0062) _Timer16_1_ISR:
                                        (0063) 
                                        (0064)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                        (0065)    ;---------------------------------------------------
                                        (0066)    ; Insert your custom code below this banner
                                        (0067)    ;---------------------------------------------------
                                        (0068)    ;   NOTE: interrupt service routines must preserve
                                        (0069)    ;   the values of the A and X CPU registers.
                                        (0070) 
                                        (0071)    ;---------------------------------------------------
                                        (0072)    ; Insert your custom code above this banner
                                        (0073)    ;---------------------------------------------------
                                        (0074)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0075) 
0458: 7E       RETI                     (0076)    reti
(0077) 
(0078) 
(0079) ; end of file Timer16_1INT.asm
FILE: lib\i2chwint.asm
                                        (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: I2CHWINT.asm
                                        (0004) ;;   Version: 1.6, Updated on 2009/10/15 at 17:11:37
                                        (0005) ;;  Generated by PSoC Designer 5.0.1127.0
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: I2CHW (Slave) Interrupt Service Routine.
                                        (0008) ;;  This is the interrupt seveice routine for the Slave I2C function.
                                        (0009) ;;-----------------------------------------------------------------------------
                                        (0010) ;;  Copyright (c) Cypress Semiconductor 2009. All Rights Reserved.
                                        (0011) ;;*****************************************************************************
                                        (0012) ;;*****************************************************************************
                                        (0013) include "m8c.inc"
                                        (0014) include "memory.inc"
                                        (0015) include "I2CHWSlave.inc"
                                        (0016) include "I2CHWCommon.inc"
                                        (0017) 
                                        (0018) 
                                        (0019) ;-----------------------------------------------
                                        (0020) ;  Global Symbols
                                        (0021) ;-----------------------------------------------
                                        (0022) export     I2CHW_RsrcStatus                                          ; upper (7x) bits write status, lower 3 bits read status
                                        (0023) export    _I2CHW_RsrcStatus                                          ; upper (7x) bits write status, lower 3 bits read status
                                        (0024) export     I2CHW_Read_Count
                                        (0025) export    _I2CHW_Read_Count
                                        (0026) export     I2CHW_Write_Count
                                        (0027) export    _I2CHW_Write_Count
                                        (0028) export    pI2CHW_Read_BufLO
                                        (0029) export   _pI2CHW_Read_BufLO
                                        (0030) export    pI2CHW_Write_BufLO
                                        (0031) export   _pI2CHW_Write_BufLO
                                        (0032) export   _I2CHW_bStatus
                                        (0033) export    I2CHW_bStatus
                                        (0034) 
                                        (0035) ;-----------------------------------------------
                                        (0036) ; WARNING: The variables below are deprecated
                                        (0037) ; and have been replaced with Read_BufLO
                                        (0038) ; and Write_BufLO
                                        (0039) ;-----------------------------------------------
                                        (0040) export    pI2CHW_Read_Buf
                                        (0041) export   _pI2CHW_Read_Buf
                                        (0042) export    pI2CHW_Write_Buf
                                        (0043) export   _pI2CHW_Write_Buf
                                        (0044) ;-----------------------------------------------
                                        (0045) ; END WARNING
                                        (0046) ;-----------------------------------------------
                                        (0047) 
                                        (0048) area InterruptRAM(RAM, REL, CON)	 
                                        (0049) 
                                        (0050) ;-----------------------------------------------
                                        (0051) ; Variable Allocation
                                        (0052) ;-----------------------------------------------
                                        (0053) 
                                        (0054)  _I2CHW_bStatus:
                                        (0055)   I2CHW_bStatus:                             blk 1
                                        (0056)   I2CHW_RsrcStatus:
                                        (0057)  _I2CHW_RsrcStatus:                          blk     1
                                        (0058)   I2CHW_Write_Count:
                                        (0059)  _I2CHW_Write_Count:                         blk    1
                                        (0060) IF SYSTEM_LARGE_MEMORY_MODEL
                                        (0061) export    pI2CHW_Write_BufHI
                                        (0062) export   _pI2CHW_Write_BufHI
                                        (0063) 
                                        (0064)  pI2CHW_Write_BufHI:
                                        (0065) _pI2CHW_Write_BufHI:                         blk     1
                                        (0066) ENDIF
                                        (0067) ;-----------------------------------------------
                                        (0068) ; WARNING: The variable below is deprecated
                                        (0069) ; and has been replaced Write_BufLO
                                        (0070) ;-----------------------------------------------
                                        (0071)  pI2CHW_Write_Buf:
                                        (0072) _pI2CHW_Write_Buf:
                                        (0073) ;-----------------------------------------------
                                        (0074) ; END WARNING
                                        (0075) ;-----------------------------------------------
                                        (0076)  pI2CHW_Write_BufLO:
                                        (0077) _pI2CHW_Write_BufLO:                         blk      1
                                        (0078) 
                                        (0079) IF I2CHW_READ_FLASH
                                        (0080) export    pI2CHW_Read_BufHI
                                        (0081) export   _pI2CHW_Read_BufHI
                                        (0082) 
                                        (0083)  pI2CHW_Read_BufHI:
                                        (0084) _pI2CHW_Read_BufHI:                          blk     1
                                        (0085) ELSE
                                        (0086) IF SYSTEM_LARGE_MEMORY_MODEL
                                        (0087) export    pI2CHW_Read_BufHI
                                        (0088) export   _pI2CHW_Read_BufHI
                                        (0089) 
                                        (0090)  pI2CHW_Read_BufHI:
                                        (0091) _pI2CHW_Read_BufHI:                          blk     1
                                        (0092) ENDIF
                                        (0093) ENDIF
                                        (0094) 
                                        (0095) ;-----------------------------------------------
                                        (0096) ; WARNING: The variable below is deprecated
                                        (0097) ; and has been replaced Read_BufLO
                                        (0098) ;-----------------------------------------------
                                        (0099)  pI2CHW_Read_Buf:
                                        (0100) _pI2CHW_Read_Buf:
                                        (0101) ;-----------------------------------------------
                                        (0102) ; END WARNING
                                        (0103) ;-----------------------------------------------
                                        (0104)  pI2CHW_Read_BufLO:
                                        (0105) _pI2CHW_Read_BufLO:                          blk       1
                                        (0106) 
                                        (0107) IF I2CHW_READ_FLASH
                                        (0108) export    I2CHW_Read_CountHI
                                        (0109) export   _I2CHW_Read_CountHI
                                        (0110) 
                                        (0111)  I2CHW_Read_CountHI:
                                        (0112) _I2CHW_Read_CountHI:                         blk    1
                                        (0113) ENDIF
                                        (0114) 
                                        (0115)  I2CHW_Read_Count:
                                        (0116) _I2CHW_Read_Count:                           blk      1
                                        (0117) 
                                        (0118) 
                                        (0119) IF I2CHW_POLLED_PROCESS
                                        (0120) 
                                        (0121) I2CHW_Poll_Status:                             blk      1  ;internal variable used for polled operation
                                        (0122) ;bit 0 - Write transaction started begin looking for the STOP state to terminate the transaction
                                        (0123) I2C_WRITE_STARTED:       equ     0x01
                                        (0124) ;bit 1 - Undefined
                                        (0125) ;bit 2 - Undefined
                                        (0126) ;bit 3 - Undefined
                                        (0127) ;bit 4 - Undefined
                                        (0128) ;bit 5 - Undefined
                                        (0129) ;bit 6 - Undefined
                                        (0130) ;bit 7 - Undefined
                                        (0131) 
                                        (0132) ENDIF
                                        (0133) 
                                        (0134) 
                                        (0135) ;@PSoC_UserCode_INIT@ (Do not change this line.)
                                        (0136) ;---------------------------------------------------
                                        (0137) ; Insert your custom declarations below this banner
                                        (0138) ;---------------------------------------------------
                                        (0139) 
                                        (0140) ;------------------------
                                        (0141) ; Includes
                                        (0142) ;------------------------
                                        (0143) 
                                        (0144) 	
                                        (0145) ;------------------------
                                        (0146) ;  Constant Definitions
                                        (0147) ;------------------------
                                        (0148) 
                                        (0149) 
                                        (0150) ;------------------------
                                        (0151) ; Variable Allocation
                                        (0152) ;------------------------
                                        (0153) 
                                        (0154) 
                                        (0155) ;---------------------------------------------------
                                        (0156) ; Insert your custom declarations above this banner
                                        (0157) ;---------------------------------------------------
                                        (0158) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0159) 
                                        (0160) 
                                        (0161) 
                                        (0162) 
                                        (0163) AREA UserModules (ROM, REL)
                                        (0164) 
                                        (0165) export _I2CHW_ISR
                                        (0166) export _I2CHW_Poll
                                        (0167) export  I2CHW_Poll
                                        (0168) 
                                        (0169) ;;****************************************************
                                        (0170) ;; I2C_ISR  main entry point from vector 60h
                                        (0171) ;;
                                        (0172) ;;****************************************************
                                        (0173) 
                                        (0174) IF I2CHW_POLLED_PROCESS
                                        (0175) 
                                        (0176) _I2CHW_ISR:
                                        (0177)     reti ; stub out the ISR if this is going to be a polled function
                                        (0178) 
                                        (0179)  
                                        (0180)  
                                        (0181)  I2CHW_Poll:
                                        (0182) _I2CHW_Poll:
                                        (0183) ;    cases are:
                                        (0184) ;    1. Stop state after a Master write to this slave
                                        (0185) ;    2. possible Stop condition COMBINED with a new transaction is not a problem since the Stop will only flag that the 
                                        (0186) ;       previous write has been completed. (so just call the I2CA_Process routine for this case and let the process routine take
                                        (0187) ;       care of it.
                                        (0188)     ;case 1
                                        (0189)     RAM_SETPAGE_CUR	( >I2CHW_Poll_Status )
                                        (0190) 
                                        (0191)     tst [I2CHW_Poll_Status], I2C_WRITE_STARTED
                                        (0192)     jz  NOT_I2C_Write
                                        (0193)     tst reg[ I2CHW_SCR], I2C_STOP_ST
                                        (0194)     jz  NOT_I2C_Write
                                        (0195)     ;make sure the pushes and pops 'line up' or die horribly
                                        (0196)     push A
                                        (0197)     push X
                                        (0198) IF SYSTEM_LARGE_MEMORY_MODEL
                                        (0199)     REG_PRESERVE IDX_PP
                                        (0200) ENDIF
                                        (0201)     jmp STOPTRAP
                                        (0202)     
                                        (0203) NOT_I2C_Write:    
                                        (0204)     tst reg[ I2CHW_SCR], I2C_BYTE_COMPL
                                        (0205)     jnz  I2CHW_Process   ;if no other critical eventa are in evidence, process an I2C byte if it's done
                                        (0206)     ret
                                        (0207) 
                                        (0208)  I2CHW_Process:
                                        (0209) _I2CHW_Process:  ;don't need to export user will call I2CA_POLL which will call the I2CA_Process routine if necessary
                                        (0210) 
                                        (0211) 
                                        (0212) 
                                        (0213) ELSE
                                        (0214) ;; STUB for polling function when it's un-defined
                                        (0215)  I2CHW_Poll:
                                        (0216) _I2CHW_Poll:
0459: 7F       RET                      (0217)     ret
                                        (0218) 
                                        (0219) 
                                        (0220) ;;*****************************************************************************************
                                        (0221) ;;                 I2C_MASTER  main entry point from vector 60h
                                        (0222) ;;*****************************************************************************************
                                        (0223) 
                                        (0224) _I2CHW_ISR:
                                        (0225) ENDIF
045A: 08       PUSH  A                  (0226)     push A
045B: 10       PUSH  X                  (0227)     push X
                                        (0228) 
                                        (0229) IF SYSTEM_LARGE_MEMORY_MODEL
045C: 5D D3    MOV   A,REG[0xD3]        
045E: 08       PUSH  A                  (0230)     REG_PRESERVE IDX_PP
                                        (0231) ENDIF
                                        (0232) 
                                        (0233) Process_REENTRY:
                                        (0234) 
                                        (0235) ;******************************************************************************************
                                        (0236) ;Before doing anything else check for the presence of a STOP_ST in combination with the
                                        (0237) ;STOP Interrupt Enable (STOPIE).  If this is what happened set appropriate bits, 
                                        (0238) ;clear and reset the main I2CHW interrupt to assure that we haven't missed a BYTE_COMPLETE
                                        (0239) ;interrupt and exit the interrupt.  If a BYTE_COMPLETE interrupt is concurrent with the STOP 
                                        (0240) ;interrupt the next entry to this interrupt will be immediate and the STOPIE bit will now be 
                                        (0241) ;cleared.  This removes the possibility of trying to process two different events within one 
                                        (0242) ;interrupt.
                                        (0243) ;          
                                        (0244) ;******************************************************************************************
                                        (0245) ; Check the Stop Bit in SCR only if the Stop Interrupt is enabled.    
                                        (0246)     IF(I2CHW_USED_I2C_BLOCK)
                                        (0247)     M8C_SetBank1
                                        (0248)     tst reg[I2CHW_CFG],I2C_STOPIE
                                        (0249)     M8C_SetBank0
                                        (0250)     ELSE
045F: 49 D6 10 TST   REG[0xD6],0x10     (0251)     tst reg[I2CHW_CFG],I2C_STOPIE
                                        (0252)     ENDIF
0462: A0 06    JZ    0x0469             (0253)     jz  ByteComplProcess
0464: 49 D7 20 TST   REG[0xD7],0x20     (0254)     tst reg[I2CHW_SCR],I2C_STOP_ST                         ; Test if the Interrupt is due to Stop Condition
                                        (0255) ;conditions that must be met here are Slave-enabled, STOP int enabled (STOPIE), and STOP_ST (status bit set)
0467: B0 EB    JNZ   0x0553             (0256)     jnz STOPTRAP                                       ; If yes process Stop Trap
                                        (0257) 
                                        (0258) ByteComplProcess:
                                        (0259) ;*********END TEST OF STOP STATUS**********************************************************       
                                        (0260) 
                                        (0261) ;       file stored in Slave directory of user module
                                        (0262) ;program flow would likely be to first determine what 'mode' the device is in.  I.e. is Master and Slave mode enabled?
                                        (0263) ; control of program flow must take more into account when all more modes are enabled.
                                        (0264) ;
                                        (0265) ;* Slave only
                                        (0266)     ;very first thing to test is the I2C_ADDRIN bit.  If set then we are getting an address after a START
0469: 49 D7 08 TST   REG[0xD7],0x8      (0267)     tst reg[I2CHW_SCR], I2C_ADDRIN
046C: B0 74    JNZ   0x04E1             (0268)     jnz I2C_EvaluateADDRIN
                                        (0269) 
                                        (0270)     ; if slave didn't recieve an address, then this must be data for it to deal with
046E: 49 D7 04 TST   REG[0xD7],0x4      (0271)     tst reg[I2CHW_SCR], I2C_TX  ;if set we are transmitting => this is at end of byte to eval the ACK
0471: B0 BE    JNZ   0x0530             (0272)     jnz I2C_EvaluateACKIN
                                        (0273)     ; if slave NOT transmitting and NOT an address then data is being recieved
                                        (0274)     ; ack it and process it.
                                        (0275) 
                                        (0276)     ;UNLESS the stop bit turns out to have been set...
0473: 49 D7 20 TST   REG[0xD7],0x20     (0277)     tst reg[I2CHW_SCR], I2C_STOP_ST
0476: B0 DC    JNZ   0x0553             (0278)     jnz STOPTRAP
                                        (0279)     ; if slave NOT transmitting and NOT an address and Master is NOT terminating the then data is being recieved
                                        (0280)     ; ack it and process it.
                                        (0281) 
                                        (0282) ;;code snipped from old SW I2C below
                                        (0283) ;
                                        (0284) ; MASTER WRITE to SLAVE
                                        (0285) ;
                                        (0286) ;@PSoC_UserCode_BODY1@ (Do not change this line.)
                                        (0287) ;---------------------------------------------------
                                        (0288) ; Insert your custom code below this banner
                                        (0289) ;---------------------------------------------------
                                        (0290) ; By modifying the section from here down to the next comment block
                                        (0291) ; a user could process data for a custom I2C WRITE application
                                        (0292) ; NOTE: I2C handshakes (ACK/NAK may be effected by any introduced bugs)
                                        (0293) ;********************************************************
0478: 47 00 04 TST   [0x0],0x4          (0294)    tst   [I2CHW_bStatus], fI2C_NAKnextWr
047B: B0 14    JNZ   0x0490             (0295)    jnz   WrStoreData
                                        (0296)    ;
                                        (0297)    ;process write data here
                                        (0298)    ;
047D: 7A 02    DEC   [0x2]              (0299)    dec   [I2CHW_Write_Count]
047F: C0 39    JC    0x04B9             (0300)    jc    I2CHW_WriteOverflow                                         ; carry set if value became -1
                                        (0301)    ;jz    WrStoreData
0481: 3C 02 00 CMP   [0x2],0x0          (0302)    cmp   [I2CHW_Write_Count], 00                                     ;set nak flag, dec count, and store data
0484: A0 03    JZ    0x0488             (0303)    jz    WrNakNextByte
0486: 80 06    JMP   0x048D             (0304)    jmp   WrNotBufEnd
                                        (0305) WrNakNextByte:                                                       ;set the nakflag in I2CHW_bStatus
0488: 2E 00 04 OR    [0x0],0x4          (0306)    or    [I2CHW_bStatus], fI2C_NAKnextWr
048B: 80 04    JMP   0x0490             (0307)    jmp   WrStoreData
                                        (0308) WrNotBufEnd:
048D: 26 00 FB AND   [0x0],0xFB         (0309)    and   [I2CHW_bStatus], ~fI2C_NAKnextWr                            ;clear the nak flag in case it was set from a previous operation
                                        (0310) WrStoreData:
                                        (0311)    ;This is the ONLY place this bit is set  This bit should never be cleared by the isr ONLY by the API ClrWrStatus()
0490: 2E 01 10 OR    [0x1],0x10         (0312)    or    [I2CHW_RsrcStatus], I2CHW_WR_NOERR                          ;set current status
                                        (0313) IF SYSTEM_LARGE_MEMORY_MODEL
0493: 51 03    MOV   A,[0x3]            (0314)    mov   A, [pI2CHW_Write_BufHI]
                                        (0315) ENDIF
0495: 60 D3    MOV   REG[0xD3],A        (0316)    RAM_SETPAGE_IDX A
0497: 58 04    MOV   X,[0x4]            (0317)    mov   X, [pI2CHW_Write_BufLO]
0499: 5D D8    MOV   A,REG[0xD8]        (0318)    mov   A, reg[I2CHW_DR]
049B: 70 3F    AND   F,0x3F             
049D: 71 80    OR    F,0x80             (0319)    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_10b
049F: 54 00    MOV   [X+0],A            (0320)    mov   [X], A
04A1: 70 3F    AND   F,0x3F             
04A3: 71 00    OR    F,0x0              (0321)    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_00b
04A5: 76 04    INC   [0x4]              (0322)    inc   [pI2CHW_Write_BufLO]
                                        (0323) 
04A7: 47 00 04 TST   [0x0],0x4          (0324)    tst   [I2CHW_bStatus], fI2C_NAKnextWr
04AA: B0 16    JNZ   0x04C1             (0325)    jnz   NAK_this_one
                                        (0326) 
                                        (0327) 
                                        (0328) ;---------------------------------------------------
                                        (0329) ; End user I2C WRITE Customization
                                        (0330) ; Insert your custom code above this banner
                                        (0331) ;---------------------------------------------------
                                        (0332) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0333) ;;code snipped form SW I2C to maintain api compatibility above
                                        (0334) 
                                        (0335) ;
                                        (0336) ;;  CONTROL MACRO- writes to the SCR register and accounts for clock speed adjustments if necessary
                                        (0337) ;
04AC: 62 D7 10 MOV   REG[0xD7],0x10     (0338)     SetI2CHW_SCR  (I2C_ACKOUT )
                                        (0339) 
                                        (0340) 
                                        (0341) IF SYSTEM_LARGE_MEMORY_MODEL
04AF: 18       POP   A                  
04B0: 60 D3    MOV   REG[0xD3],A        (0342)     REG_RESTORE IDX_PP
                                        (0343) ENDIF
04B2: 20       POP   X                  (0344)     pop X
04B3: 18       POP   A                  (0345)     pop A
04B4: 70 3F    AND   F,0x3F             
04B6: 71 C0    OR    F,0xC0             (0346)     RAM_RESTORE_NATIVE_PAGING      		;has no effect if this is an ISR
04B8: 7E       RETI                     (0347)     I2CHW_SERVICE_RETURN
                                        (0348) 
                                        (0349) 
                                        (0350) ;
                                        (0351) ;ram-write-overflow label here, just rewrite the last location in the buffer
                                        (0352) ;    and set the overflow flag
                                        (0353) ;
                                        (0354) I2CHW_WriteOverflow:
04B9: 2E 01 20 OR    [0x1],0x20         (0355)    or    [I2CHW_RsrcStatus], I2CHW_WR_OVERFLOW                       ; flag the overflow
04BC: 26 01 EF AND   [0x1],0xEF         (0356)    and   [I2CHW_RsrcStatus], ~I2CHW_WR_NOERR
04BF: 76 02    INC   [0x2]              (0357)    inc   [I2CHW_Write_Count]                                         ; put it back to zero
                                        (0358)    ;If data is to be Nak'ed
                                        (0359) NAK_this_one:
04C1: 26 00 FB AND   [0x0],0xFB         (0360)    and   [I2CHW_bStatus], ~fI2C_NAKnextWr                            ;clear the nak flag in case it was set from a previous operation
                                        (0361) 
                                        (0362) ;
                                        (0363) ;;  CONTROL MACRO- writes to the SCR register and accounts for clock speed adjustments if necessary
                                        (0364) ;
04C4: 62 D7 00 MOV   REG[0xD7],0x0      (0365)     SetI2CHW_SCR ( 0 )
                                        (0366) 
                                        (0367) 
                                        (0368) IF SYSTEM_LARGE_MEMORY_MODEL
04C7: 18       POP   A                  
04C8: 60 D3    MOV   REG[0xD3],A        (0369)     REG_RESTORE IDX_PP
                                        (0370) ENDIF
04CA: 20       POP   X                  (0371)     pop X
04CB: 18       POP   A                  (0372)     pop A
04CC: 70 3F    AND   F,0x3F             
04CE: 71 C0    OR    F,0xC0             (0373)     RAM_RESTORE_NATIVE_PAGING      		;has no effect if this is an ISR
04D0: 7E       RETI                     (0374)     I2CHW_SERVICE_RETURN                                                              ;return and wait for the next interrupt (on data)
                                        (0375) 
                                        (0376) 
                                        (0377) ;********************************************************
                                        (0378) ; Treat the case where the Slave will be continuing to
                                        (0379) ; receive data after receiving the address
                                        (0380) ;********************************************************
                                        (0381) I2C_AckAddr_RXdata:
                                        (0382) IF I2CHW_POLLED_PROCESS
                                        (0383)     or [I2CHW_Poll_Status], I2C_WRITE_STARTED
                                        (0384) ELSE
04D1: 43 D6 10 OR    REG[0xD6],0x10     (0385)     BitSetI2CHW_CFG ( I2C_STOPIE )
                                        (0386) ENDIF
                                        (0387) 
                                        (0388) ;
                                        (0389) ;;  CONTROL MACRO- writes to the SCR register and accounts for clock speed adjustments if necessary
                                        (0390) ;
04D4: 62 D7 10 MOV   REG[0xD7],0x10     (0391)     SetI2CHW_SCR ( I2C_ACKOUT )
                                        (0392) 
                                        (0393) 
                                        (0394) IF SYSTEM_LARGE_MEMORY_MODEL
04D7: 18       POP   A                  
04D8: 60 D3    MOV   REG[0xD3],A        (0395)     REG_RESTORE IDX_PP
                                        (0396) ENDIF
04DA: 20       POP   X                  (0397)     pop X
04DB: 18       POP   A                  (0398)     pop A
04DC: 70 3F    AND   F,0x3F             
04DE: 71 C0    OR    F,0xC0             (0399)     RAM_RESTORE_NATIVE_PAGING      		;has no effect if this is an ISR
04E0: 7E       RETI                     (0400)     I2CHW_SERVICE_RETURN
                                        (0401) 
                                        (0402) ;********************************************************
                                        (0403) ; Look to see if the address is us or someone else
                                        (0404) ; use the carry flag to idendify a READ or WRITE address
                                        (0405) ;********************************************************
                                        (0406) I2C_EvaluateADDRIN:
04E1: 51 01    MOV   A,[0x1]            (0407)     mov A, [I2CHW_RsrcStatus]
04E3: 21 30    AND   A,0x30             (0408)     and A, (I2CHW_WR_NOERR | I2CHW_WR_OVERFLOW)
04E5: A0 07    JZ    0x04ED             (0409)     jz  NewADDRNotSet                                                                                             ;set new addr only if previous data appears to be in buffer
04E7: 2E 01 40 OR    [0x1],0x40         (0410)     or  [I2CHW_RsrcStatus], I2CHW_WR_COMPLETE                        ;Same bit as I2CHW_ISR_NEW_ADDR
                                        (0411) 
                                        (0412) IF I2CHW_POLLED_PROCESS						                                ;if a new addr was received it's OK to terminate stop detection
                                        (0413)     and [I2CHW_Poll_Status], ~I2C_WRITE_STARTED              ;used to determine the end of a Master write to a slave.
                                        (0414) ELSE			
04EA: 41 D6 EF AND   REG[0xD6],0xEF     (0415)     BitClrI2CHW_CFG I2C_STOPIE
                                        (0416) ENDIF
                                        (0417)                                                                                                                                           ;SET WR_COMPL bit if it appears there was write taking place just previous
                                        (0418) NewADDRNotSet:                                                       ;may use as a way to tag the end of a master write to slave
                                        (0419) ;@PSoC_UserCode_BODY4@ (Do not change this line.)
                                        (0420) ;---------------------------------------------------
                                        (0421) ; Insert your custom code below this banner
                                        (0422) ;---------------------------------------------------
                                        (0423) ; By replacing the section from here down to the next block
                                        (0424) ; a user could process I2C addresses differently
                                        (0425) ;********************************************************
                                        (0426)                                                                                                                                           ;to this new address by looking at the status bits
                                        (0427)     ;inc [rec_cnt]
04ED: 5D D8    MOV   A,REG[0xD8]        (0428)     mov A, reg[I2CHW_DR]
04EF: 70 F9    AND   F,0xF9             (0429)     and F, 0xF9                                                      ;clear Carry (C) AND Zero (Z) in Flag reg
04F1: 6D       RRC   A                  (0430)     rrc A                                                            ;carry now holds bit 0 (r/~w) from addr byte
                                        (0431) IF (I2CHW_AUTO_ADDR_CHECK^1)   ;; for CY8C28X45 chip: skip address comparison and NACK sending stage-hardware will do this for us  if AutoAddressCompare feature is enabled.
                                        (0432)                                           ;; The code in this pre-compiler directive will be executed for all chips except CY8C28X45.
04F2: 31 11    XOR   A,0x11             (0433)     xor A,  I2CHW_SLAVE_ADDR                                         ;for an equate
04F4: B0 4E    JNZ   0x0543             (0434)     jnz I2C_Terminate
                                        (0435) ENDIF
04F6: 2E 01 80 OR    [0x1],0x80         (0436)     or [I2CHW_RsrcStatus], I2CHW_ISR_ACTIVE
                                        (0437) 
                                        (0438) ;********************************************************
                                        (0439) ; User could modify this section to allow the I2C routine
                                        (0440) ; to respond to multiple addresses, ram addresses, i/o pin
                                        (0441) ; based addresses, etc.
                                        (0442) ;********************************************************
                                        (0443) ;---------------------------------------------------
                                        (0444) ; End user I2C ADDR Compare Customization
                                        (0445) ; Insert your custom code above this banner
                                        (0446) ;---------------------------------------------------
                                        (0447) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0448) 
                                        (0449) I2CHW_send_ack:                                                      ;slave send adress ack
                                        (0450) 
                                        (0451) 
                                        (0452)     ;OK so the addreses were the same was it a read (c=1) or a write (c=0)
04F9: DF D7    JNC   0x04D1             (0453)     jnc I2C_AckAddr_RXdata ;(Master Write/Slave Receive) for this case we receive data and ack it
                                        (0454) 
                                        (0455) ;********************************************************
                                        (0456) ;Master Read (Master Read/Slave Transmit) Ack the address too.
                                        (0457) ;for this case the master has just sent us OUR read address which must be Ack'ed and will
                                        (0458) ;subsequently be reading from us (which the master will Ack.  So for the first bit we must
                                        (0459) ; set the I2C_TX AND the ACK bits in the I2C_SCR (first byte only)
                                        (0460) ; THEN we'll just be reading the ACK from the master as it reads our data
                                        (0461) ;********************************************************
                                        (0462) 
04FB: 26 01 FB AND   [0x1],0xFB         (0463)     and [I2CHW_RsrcStatus], ~I2CHW_RD_COMPLETE                       ;Master will NAK us at the end of transaction
                                        (0464) 
04FE: 50 14    MOV   A,0x14             (0465)     mov A, (I2C_ACKOUT | I2C_TX)
0500: 08       PUSH  A                  (0466)     push A
                                        (0467) 
                                        (0468) 
                                        (0469) ;
                                        (0470) ;MASTER is READING FROM SLAVE (ram or flash buffer)
                                        (0471) ;
                                        (0472) ;;code snipped from old SW I2C below
                                        (0473) 
                                        (0474) I2C_ObtainReadData:
                                        (0475) 
                                        (0476) ;********************************************************
                                        (0477) ; here we need to get the next data to output (master-read)
                                        (0478) ; also set the status byte for use on exit
                                        (0479) ;********************************************************
                                        (0480) IF I2CHW_READ_FLASH
                                        (0481) ;@PSoC_UserCode_BODY2@ (Do not change this line.)
                                        (0482) ;---------------------------------------------------
                                        (0483) ; Insert your custom code below this banner
                                        (0484) ; User flash read customization could take place within
                                        (0485) ; this area
                                        (0486) ;---------------------------------------------------
                                        (0487)     tst  [I2CHW_RsrcStatus],I2CHW_READFLASH
                                        (0488)     jz   ReadRamData
                                        (0489) 
                                        (0490)     ;
                                        (0491)     ;get the data
                                        (0492)     ;
                                        (0493)     mov  X, [pI2CHW_Read_BufLO]
                                        (0494)     mov  A, [pI2CHW_Read_BufHI]
                                        (0495)     romx
                                        (0496)     mov  reg[I2CHW_DR],A
                                        (0497)     dec  [I2CHW_Read_Count]                                          ;calc addr lsb
                                        (0498)     jnc  NoDecHighCount
                                        (0499)     dec  [I2CHW_Read_CountHI]
                                        (0500)     jc   FlashRdOverflow
                                        (0501) 
                                        (0502) NoDecHighCount:
                                        (0503) 
                                        (0504)     inc  [pI2CHW_Read_BufLO]                                         ;set the next flash address to read
                                        (0505)     jnc  NoIncHiAddr
                                        (0506)     inc  [pI2CHW_Read_BufHI]
                                        (0507) NoIncHiAddr:
                                        (0508)    jmp   I2CNormalRead
                                        (0509) 
                                        (0510) FlashRdOverflow:
                                        (0511)     ;deal with the over flow cond by resending last data byte (dec the low order addr byte)
                                        (0512) 
                                        (0513)    or    [I2CHW_RsrcStatus], I2CHW_RD_OVERFLOW
                                        (0514)    and   [I2CHW_RsrcStatus], ~I2CHW_RD_NOERR
                                        (0515)    ;set count back to 0
                                        (0516)    mov   [I2CHW_Read_CountHI], 0                                     ;functionally the same as incrementing ffff and less instructions
                                        (0517)    mov   [I2CHW_Read_Count], 0
                                        (0518)    jmp   I2CNormalRead
                                        (0519) ;---------------------------------------------------
                                        (0520) ; Insert your custom code above this banner
                                        (0521) ; END User flash read customization
                                        (0522) ;---------------------------------------------------
                                        (0523) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0524) ENDIF
                                        (0525) ;@PSoC_UserCode_BODY3@ (Do not change this line.)
                                        (0526) ;---------------------------------------------------
                                        (0527) ; Insert your custom code below this banner
                                        (0528) ;---------------------------------------------------
                                        (0529) ; By replacing the section from here down to the next block
                                        (0530) ; a user could process data for a custom I2C READ application
                                        (0531) ;********************************************************
                                        (0532) ReadRamData:
                                        (0533)    ;read the current data byte
                                        (0534) IF SYSTEM_LARGE_MEMORY_MODEL
0501: 51 05    MOV   A,[0x5]            (0535)    mov   A, [pI2CHW_Read_BufHI]
                                        (0536) ENDIF
0503: 60 D3    MOV   REG[0xD3],A        (0537)    RAM_SETPAGE_IDX A
0505: 58 06    MOV   X,[0x6]            (0538)    mov   X, [pI2CHW_Read_BufLO]
0507: 70 3F    AND   F,0x3F             
0509: 71 80    OR    F,0x80             (0539)    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_10b
050B: 52 00    MOV   A,[X+0]            (0540)    mov   A, [X]
050D: 70 3F    AND   F,0x3F             
050F: 71 00    OR    F,0x0              (0541)    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_00b
0511: 60 D8    MOV   REG[0xD8],A        (0542)    mov   reg[I2CHW_DR], A
0513: 7A 07    DEC   [0x7]              (0543)    dec   [I2CHW_Read_Count]
0515: C0 05    JC    0x051B             (0544)    jc    I2CHW_readOverflow
0517: 76 06    INC   [0x6]              (0545)    inc   [pI2CHW_Read_BufLO]
0519: 80 09    JMP   0x0523             (0546)    jmp   I2CNormalRead
                                        (0547) ;
                                        (0548) ;ram read overflow detected here, just resend the last location in the buffer
                                        (0549) ;
                                        (0550) I2CHW_readOverflow:
051B: 2E 01 02 OR    [0x1],0x2          (0551)    or    [I2CHW_RsrcStatus], I2CHW_RD_OVERFLOW
051E: 26 01 FE AND   [0x1],0xFE         (0552)    and   [I2CHW_RsrcStatus], ~I2CHW_RD_NOERR
0521: 76 07    INC   [0x7]              (0553)    inc   [I2CHW_Read_Count]                                          ; set back to zero
                                        (0554) 
                                        (0555) ;********************************************************
                                        (0556) ; End user I2C READ customization section
                                        (0557) ;********************************************************
                                        (0558) ; Insert your custom code above this banner
                                        (0559) ;---------------------------------------------------
                                        (0560) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0561) 
                                        (0562) ;;code snipped form SW I2C to maintain api compatibility above
                                        (0563) I2CNormalRead:
                                        (0564) 
                                        (0565)         ;load the bits to set in the I2C_ISR from the stack, The proper bit pattern was previously determined
                                        (0566)         ;and place there based on whether or not the previous transmission was our I2C address.
0523: 18       POP   A                  (0567)         pop A
                                        (0568) 
                                        (0569) ;
                                        (0570) ;;  CONTROL MACRO- writes to the SCR register and accounts for clock speed adjustments if necessary
                                        (0571) ;
0524: 60 D7    MOV   REG[0xD7],A        (0572)     SetI2CHW_SCR A     ;set read bit as (bit0) and Addr bit (bit7)in the I2C_SCR
                                        (0573) 
                                        (0574) 
                                        (0575) IF SYSTEM_LARGE_MEMORY_MODEL
0526: 18       POP   A                  
0527: 60 D3    MOV   REG[0xD3],A        (0576)     REG_RESTORE IDX_PP
                                        (0577) ENDIF
0529: 20       POP   X                  (0578)     pop X
052A: 18       POP   A                  (0579)     pop A
052B: 70 3F    AND   F,0x3F             
052D: 71 C0    OR    F,0xC0             (0580)     RAM_RESTORE_NATIVE_PAGING      		;has no effect if this is an ISR
052F: 7E       RETI                     (0581)     I2CHW_SERVICE_RETURN ;return and wait for the next interrupt (on data)
                                        (0582) 
                                        (0583) 
                                        (0584) 
                                        (0585) I2C_EvaluateACKIN:
                                        (0586) 
0530: 49 D7 02 TST   REG[0xD7],0x2      (0587)     tst reg[I2CHW_SCR], I2C_LST_BIT
0533: B0 06    JNZ   0x053A             (0588)     jnz I2C_LastByteToMstr  ;NAK recd on TX so this is the end set mode to interrup only on ADDR IN
                                        (0589)     ; got here we were ACK'ed so send another byte
0535: 50 04    MOV   A,0x4              (0590)     mov A, ( I2C_TX )
                                        (0591)         ;load the bits to set in the I2C_ISR from the stack, The proper bit pattern was previously determined
                                        (0592)         ;and place there based on whether or not the previous transmission was our I2C address.
0537: 08       PUSH  A                  (0593)         push A
0538: 8F C8    JMP   0x0501             (0594)         jmp I2C_ObtainReadData
                                        (0595) 
                                        (0596) 
                                        (0597) I2C_LastByteToMstr:
053A: 2E 01 01 OR    [0x1],0x1          (0598)     or  [I2CHW_RsrcStatus], I2CHW_RD_NOERR                           ;Master NAK'ed us at the end of transaction
053D: 2E 01 04 OR    [0x1],0x4          (0599)     or  [I2CHW_RsrcStatus], I2CHW_RD_COMPLETE
0540: 26 01 7F AND   [0x1],0x7F         (0600)     and [I2CHW_RsrcStatus], ~I2CHW_ISR_ACTIVE
                                        (0601) 
                                        (0602) I2C_Terminate:
0543: 26 01 7F AND   [0x1],0x7F         (0603)     and [I2CHW_RsrcStatus], ~I2CHW_ISR_ACTIVE
                                        (0604) 
                                        (0605) ;
                                        (0606) ;;  CONTROL MACRO- writes to the SCR register and accounts for clock speed adjustments if necessary
                                        (0607) ;
0546: 62 D7 00 MOV   REG[0xD7],0x0      (0608)     SetI2CHW_SCR 0     ;the default mode to wait for an address
                                        (0609) 
                                        (0610) 
                                        (0611) IF SYSTEM_LARGE_MEMORY_MODEL
0549: 18       POP   A                  
054A: 60 D3    MOV   REG[0xD3],A        (0612)     REG_RESTORE IDX_PP
                                        (0613) ENDIF
054C: 20       POP   X                  (0614)     pop X
054D: 18       POP   A                  (0615)     pop A
054E: 70 3F    AND   F,0x3F             
0550: 71 C0    OR    F,0xC0             (0616)     RAM_RESTORE_NATIVE_PAGING      		;has no effect if this is an ISR
0552: 7E       RETI                     (0617)     I2CHW_SERVICE_RETURN
                                        (0618) 
                                        (0619) STOPTRAP:
                                        (0620)     ;I2C stop detected
                                        (0621) ;@PSoC_UserCode_BODY6@ (Do not change this line.)
                                        (0622) ;---------------------------------------------------
                                        (0623) ; Insert your custom code below this banner
                                        (0624) ; by modifying the block of code here a user could address key operational considerations
                                        (0625) ; at the point that a termination of a write command is detected.
                                        (0626) ; stop interrupt is automatically enabled on write so that the end of the write can be determined.
                                        (0627) ; stop interrupt is not enabled when a read transaction occurs
                                        (0628) ;---------------------------------------------------
                                        (0629) ;
                                        (0630) ; set a flag to indicate END OF TRANSMISSION
                                        (0631) ;
0553: 2E 01 40 OR    [0x1],0x40         (0632)     or  [I2CHW_RsrcStatus], I2CHW_WR_COMPLETE                        ;only SET by ISR USER must clear.
0556: 26 01 7F AND   [0x1],0x7F         (0633)     and [I2CHW_RsrcStatus], ~I2CHW_ISR_ACTIVE
                                        (0634) 
                                        (0635) IF I2CHW_POLLED_PROCESS
                                        (0636)     and [I2CHW_Poll_Status], ~I2C_WRITE_STARTED
                                        (0637)     jmp ExitISR
                                        (0638) ELSE
0559: 41 D6 EF AND   REG[0xD6],0xEF     (0639)     BitClrI2CHW_CFG I2C_STOPIE
055C: 49 D7 01 TST   REG[0xD7],0x1      (0640)     tst reg[I2CHW_SCR], I2C_BYTE_COMPL
                                        (0641) ;;if BYTE_COMPL is set, there's an excellent chance to lose an ISR.  Because of the way they are
                                        (0642) ;; latched into the INT_MSK.  Therefore clear the applicable bit (STOPIE) and jump directly to the 
                                        (0643) ;; top of this routing since the bus is currently stalled.  Just in case the ISR is properly latched,
                                        (0644) ;; clear the mask bit since it's is serviced manually.
055F: A0 06    JZ    0x0566             (0645)     jz ExitISR
0561: 41 DD FE AND   REG[0xDD],0xFE     (0646)     and  reg[INT_CLR3], ~0x01                                ;clear the I2C interrupt
                                        (0647) ENDIF
                                        (0648) 
0564: 8E FA    JMP   0x045F             (0649) 	jmp Process_REENTRY
                                        (0650) 
                                        (0651) ExitISR:
                                        (0652) 
                                        (0653) IF SYSTEM_LARGE_MEMORY_MODEL
0566: 18       POP   A                  
0567: 60 D3    MOV   REG[0xD3],A        (0654)     REG_RESTORE IDX_PP
                                        (0655) ENDIF
0569: 20       POP   X                  (0656)     pop X
056A: 18       POP   A                  (0657)     pop A
056B: 70 3F    AND   F,0x3F             
056D: 71 C0    OR    F,0xC0             (0658)     RAM_RESTORE_NATIVE_PAGING      		;has no effect if this is an ISR
056F: 7E       RETI                     (0659)     I2CHW_SERVICE_RETURN
(0660) 
(0661) ;---------------------------------------------------
(0662) ; End user boot loader entry Customization
(0663) ; Insert your custom code above this banner
(0664) ;---------------------------------------------------
(0665) ;@PSoC_UserCode_END@ (Do not change this line.)
(0666) 
(0667) ; end of file I2CHWINT.asm
FILE: lib\adcincvr_4int.asm
                                        (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME:   ADCINCVR_4INT.asm
                                        (0004) ;;  Version: 3.1, Updated on 2009/10/15 at 17:11:37
                                        (0005) ;;  Generated by PSoC Designer 5.0.1127.0
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: ADCINCVR Interrupt Service Routines
                                        (0008) ;;-----------------------------------------------------------------------------
                                        (0009) ;;  Copyright (c) Cypress Semiconductor 2009. All Rights Reserved.
                                        (0010) ;;*****************************************************************************
                                        (0011) ;;*****************************************************************************
                                        (0012) 
                                        (0013) include "m8c.inc"
                                        (0014) include "memory.inc"
                                        (0015) include "ADCINCVR_4.inc"
                                        (0016) 
                                        (0017) ;-----------------------------------------------
                                        (0018) ;  Global Symbols
                                        (0019) ;-----------------------------------------------
                                        (0020) export _ADCINCVR_4_CNT_ISR
                                        (0021) export _ADCINCVR_4_PWM16_ISR
                                        (0022) export  ADCINCVR_4_cCounterU
                                        (0023) export _ADCINCVR_4_iResult
                                        (0024) export  ADCINCVR_4_iResult
                                        (0025) export _ADCINCVR_4_bfStatus
                                        (0026) export  ADCINCVR_4_bfStatus
                                        (0027) export  ADCINCVR_4_bSampC
                                        (0028) 
                                        (0029) ;-----------------------------------------------
                                        (0030) ; Variable Allocation
                                        (0031) ;-----------------------------------------------
                                        (0032) AREA InterruptRAM(RAM, REL, CON)
                                        (0033) 
                                        (0034)  ADCINCVR_4_cCounterU:     BLK   1  ;The Upper byte of the Counter
                                        (0035) _ADCINCVR_4_iResult:
                                        (0036)  ADCINCVR_4_iResult:       BLK   2  ;A/D value
                                        (0037) _ADCINCVR_4_bfStatus:
                                        (0038)  ADCINCVR_4_bfStatus:      BLK   1  ;Data Valid Flag
                                        (0039)  ADCINCVR_4_bSampC:        BLK   1  ;# of times to run A/D
                                        (0040) 
                                        (0041) 
                                        (0042) ;-----------------------------------------------
                                        (0043) ;  EQUATES and TABLES
                                        (0044) ;-----------------------------------------------
                                        (0045) LowByte:   equ 1
                                        (0046) HighByte:  equ 0
                                        (0047) 
                                        (0048) 
                                        (0049) ;@PSoC_UserCode_INIT@ (Do not change this line.)
                                        (0050) ;---------------------------------------------------
                                        (0051) ; Insert your custom declarations below this banner
                                        (0052) ;---------------------------------------------------
                                        (0053) 
                                        (0054) ;------------------------
                                        (0055) ; Includes
                                        (0056) ;------------------------
                                        (0057) 
                                        (0058) 	
                                        (0059) ;------------------------
                                        (0060) ;  Constant Definitions
                                        (0061) ;------------------------
                                        (0062) 
                                        (0063) 
                                        (0064) ;------------------------
                                        (0065) ; Variable Allocation
                                        (0066) ;------------------------
                                        (0067) 
                                        (0068) 
                                        (0069) ;---------------------------------------------------
                                        (0070) ; Insert your custom declarations above this banner
                                        (0071) ;---------------------------------------------------
                                        (0072) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0073) 
                                        (0074) AREA UserModules (ROM, REL)
                                        (0075) 
                                        (0076) .LITERAL
                                        (0077) ADCINCVR_4MaxNegX4Table:
                                        (0078) ; Bits  7    8    9   10   11   12   13
                                        (0079)    DB  FFh, FEh, FCh, F8h, F0h, E0h, C0h
                                        (0080) 
                                        (0081) ADCINCVR_4MaxPosX4Table:
                                        (0082) IF (ADCINCVR_4_DATA_FORMAT)
                                        (0083) ; Bits (signed)    7    8    9   10   11   12   13
                                        (0084)               DB  01h, 02h, 04h, 08h, 10h, 20h, 40h
                                        (0085) ELSE
                                        (0086) ; Bits (unsigned)  7    8    9   10   11   12   13
                                        (0087)               DB  02h, 04h, 08h, 10h, 20h, 40h, 80h
                                        (0088) 
                                        (0089)  ENDIF
                                        (0090) .ENDLITERAL
                                        (0091) 
                                        (0092) ;-----------------------------------------------------------------------------
                                        (0093) ;  FUNCTION NAME: _ADCINCVR_4_CNT_ISR (Counter8 Interrupt)
                                        (0094) ;
                                        (0095) ;
                                        (0096) ;  DESCRIPTION:
                                        (0097) ;     Increment the upper (software) half on the counter whenever the
                                        (0098) ;     lower (hardware) half of the counter underflows.  This counter
                                        (0099) ;     should start out at the most negative value (0xFF).
                                        (0100) ;
                                        (0101) ;-----------------------------------------------------------------------------
                                        (0102) ;
                                        (0103) _ADCINCVR_4_CNT_ISR:

(0104)    inc [ADCINCVR_4_cCounterU]
                                        (0105)    ;@PSoC_UserCode_BODY_1@ (Do not change this line.)
                                        (0106)    ;---------------------------------------------------
                                        (0107)    ; Insert your custom code below this banner
                                        (0108)    ;---------------------------------------------------
                                        (0109)    ;   NOTE: interrupt service routines must preserve
                                        (0110)    ;   the values of the A and X CPU registers.
                                        (0111) 
                                        (0112)    ;---------------------------------------------------
                                        (0113)    ; Insert your custom code above this banner
                                        (0114)    ;---------------------------------------------------
                                        (0115)    ;@PSoC_UserCode_END@ (Do not change this line.)
057F: 08       PUSH  A                  
0580: 7E       RETI                     (0116)    reti
                                        (0117) 
                                        (0118) 
                                        (0119) ;-----------------------------------------------------------------------------
                                        (0120) ;  FUNCTION NAME: _ADCINCVR_4_PWM16_ISR  (PWM16 Interrupt)
                                        (0121) ;
                                        (0122) ;  DESCRIPTION:
                                        (0123) ;     This ISR is called when the ADC has completed and integrate cycle.
                                        (0124) ;     The ADC value is calculated and stored in a global location before
                                        (0125) ;     the end of the ISR.
                                        (0126) ;
                                        (0127) ;-----------------------------------------------------------------------------
                                        (0128) ;
                                        (0129) _ADCINCVR_4_PWM16_ISR:
0581: 41 37 FE AND   REG[0x37],0xFE     (0130)    and   reg[ADCINCVR_4_bCounter_CR0], ~ADCINCVR_4_fDBLK_ENABLE  ; Disable Counter
                                        (0131) IF ADCINCVR_4_NoAZ
0584: 43 8E 20 OR    REG[0x8E],0x20     (0132)    or    reg[ADCINCVR_4_bfAtoDcr2], ADCINCVR_4_fAutoZero      ; Put Integrator in AutoZero
                                        (0133) ENDIF
0587: 43 8F 10 OR    REG[0x8F],0x10     (0134)    or   reg[ADCINCVR_4_bfAtoDcr3],ADCINCVR_4_fFSW0         ; Put Integrator in reset
                                        (0135) 
                                        (0136)                                                            ; Enable interrupts for a short period of time just in case.
                                        (0137)                                                            ; Make sure we didn't have a counter interrupt ready to fire
058A: 71 01    OR    F,0x1              (0138)    M8C_EnableGInt
058C: 40       NOP                      (0139)    nop                                                     ; Wait a couple cycles
058D: 70 FE    AND   F,0xFE             (0140)    M8C_DisableGInt                                         ; Disable interrupt, read to complete processing
058F: 08       PUSH  A                  (0141)    push  A                                                 ; Save the Accumulator
0590: 5D 34    MOV   A,REG[0x34]        (0142)    mov   A,reg[ADCINCVR_4_bCount]                          ; Read counter value  (Bogus read puts value in Period register)
0592: 5D 36    MOV   A,REG[0x36]        (0143)    mov   A,reg[ADCINCVR_4_bCompare]                        ; Read counter value
0594: 78       DEC   A                  (0144)    dec   A                                                 ; Decrement by one to make sure we didn't miss a count
0595: 73       CPL   A                  (0145)    cpl   A                                                 ; Invert the value
0596: D0 03    JNC   0x059A             (0146)    jnc   ADCINCVR_4_INT_CALCV                              ; if carry, then inc MSB as well
0598: 76 08    INC   [0x8]              (0147)    inc   [ADCINCVR_4_cCounterU]
                                        (0148) ADCINCVR_4_INT_CALCV:
059A: 53 0A    MOV   [0xA],A            (0149)    mov   [(ADCINCVR_4_iResult + LowByte)], A               ; Store LSB value
059C: 51 08    MOV   A,[0x8]            (0150)    mov   A, [ADCINCVR_4_cCounterU]                         ; Store MSB from temp counter
059E: 53 09    MOV   [0x9],A            (0151)    mov   [(ADCINCVR_4_iResult + HighByte)], A
                                        (0152)                                                            ; The new value has been stored,
                                        (0153)                                                            ; so get counters ready for next reading first.
05A0: 62 35 FF MOV   REG[0x35],0xFF     (0154)    mov   reg[ADCINCVR_4_bPeriod], ffh                      ; Initialize counter to FF - Set to overflow after 256 counts
05A3: 43 37 01 OR    REG[0x37],0x1      (0155)    or    reg[ADCINCVR_4_bCounter_CR0],ADCINCVR_4_fDBLK_ENABLE  ; Enable Counter
                                        (0156) 
                                        (0157) IF (ADCINCVR_4_DATA_FORMAT)                                ; Only check for Negative numbers if SIGNED result
                                        (0158)    mov   A, [ADCINCVR_4_bfStatus]                          ; Get Status with Resolution
                                        (0159)    and   A, ADCINCVR_4_bRES_MASK                           ; Mask of resolution
                                        (0160)    index ADCINCVR_4MaxNegX4Table                           ; Get Maximum negative value from table
                                        (0161)    mov   [ADCINCVR_4_cCounterU], A                         ; Place result back into MSB of counter
                                        (0162) ELSE
05A6: 55 08 00 MOV   [0x8],0x0          (0163)    mov   [ADCINCVR_4_cCounterU], 00h                       ; Place result back into MSB of counter
                                        (0164) ENDIF
                                        (0165) 
                                        (0166)    ;@PSoC_UserCode_BODY_2@ (Do not change this line.)
                                        (0167)    ;---------------------------------------------------
                                        (0168)    ; If the input is muxed with multiple inputs
                                        (0169)    ; this is a good place to change inputs.
                                        (0170)    ; Insert your custom code below this banner
                                        (0171)    ;---------------------------------------------------
                                        (0172)    ;   NOTE: interrupt service routines must preserve
                                        (0173)    ;   the values of the A and X CPU registers. At this
                                        (0174)    ;   point A is already preserved and will be restored;
                                        (0175)    ;   however, if you use X, you must take care of it
                                        (0176)    ;   here!
                                        (0177) 
                                        (0178)    ;---------------------------------------------------
                                        (0179)    ; Insert your custom code above this banner
                                        (0180)    ;---------------------------------------------------
                                        (0181)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0182) 
05A9: 41 8F EF AND   REG[0x8F],0xEF     (0183)    and   reg[ADCINCVR_4_bfAtoDcr3],~ADCINCVR_4_fFSW0       ; Take Integrator out of reset
                                        (0184) IF ADCINCVR_4_NoAZ
05AC: 41 8E DF AND   REG[0x8E],0xDF     (0185)    and   reg[ADCINCVR_4_bfAtoDcr2],~ADCINCVR_4_fAutoZero   ; Take Integrator out of AutoZero
                                        (0186) ENDIF
                                        (0187) 
                                        (0188)    ;****************************************************************************
                                        (0189)    ;M8C_EnableGInt            ; May want to re-enable interrupts at this point,
                                        (0190)    ;                          ; if stack space isn't at a premium.
                                        (0191)    ; NOTE:  this will make system more responsive but, will increase the
                                        (0192)    ;        overall processing time of the A/D calctime.  If an interrupt is
                                        (0193)    ;        taken, it must return within the specified CalcTime to guarantee
                                        (0194)    ;        successful acquisition of the next byte.
                                        (0195)    ;****************************************************************************
                                        (0196) IF (ADCINCVR_4_DATA_FORMAT)                      ; Only check for Negative numbers if SIGNED result
                                        (0197) 
                                        (0198)                                                  ; Negative Overflow Check
                                        (0199)    tst   [(ADCINCVR_4_iResult + HighByte)],80h
                                        (0200)    jnz   ADCINCVR_4_NOT_POVFL2
                                        (0201) 
                                        (0202) ENDIF
                                        (0203)                                                  ; Postive Overflow Check
                                        (0204)                                                  ; Get MSB of Max Positive value x4 + 1
05AF: 51 0B    MOV   A,[0xB]            (0205)    mov   A,[ADCINCVR_4_bfStatus]                 ; Get Status with Resolution
05B1: 21 0F    AND   A,0xF              (0206)    and   A,ADCINCVR_4_bRES_MASK                  ; Mask of resolution normalized to 0
05B3: FF C2    INDEX 0x0577             (0207)    index ADCINCVR_4MaxPosX4Table                 ; Get Maximum positive value x4 + 1 from table
05B5: 08       PUSH  A                  (0208)    push  A
05B6: 22 09    AND   A,[0x9]            (0209)    and   A, [(ADCINCVR_4_iResult + HighByte)]
05B8: A0 0B    JZ    0x05C4             (0210)    jz    ADCINCVR_4_NOT_POVFL
                                        (0211)                                                  ; Positive overflow, fix it - set to Max Positive + 1
05BA: 18       POP   A                  (0212)    pop   A
05BB: 11 01    SUB   A,0x1              (0213)    sub   A, 01h
                                        (0214) 
                                        (0215)                                                  ; Force most positive * 4 into result
05BD: 53 09    MOV   [0x9],A            (0216)    mov   [(ADCINCVR_4_iResult + HighByte)], A
05BF: 55 0A FF MOV   [0xA],0xFF         (0217)    mov   [(ADCINCVR_4_iResult + LowByte)], ffh
05C2: 80 02    JMP   0x05C5             (0218)    jmp   ADCINCVR_4_NOT_POVFL2
                                        (0219) ADCINCVR_4_NOT_POVFL:
05C4: 18       POP   A                  (0220)    pop   A
                                        (0221) 
                                        (0222) ADCINCVR_4_NOT_POVFL2:
05C5: 68 09    ASR   [0x9]              (0223)    asr   [(ADCINCVR_4_iResult + HighByte)]       ; Shift MSB and LSB right twice to divide by four
05C7: 6E 0A    RRC   [0xA]              (0224)    rrc   [(ADCINCVR_4_iResult + LowByte)]        ; Remember digital clock 4 times analog clock
05C9: 68 09    ASR   [0x9]              (0225)    asr   [(ADCINCVR_4_iResult + HighByte)]
05CB: 6E 0A    RRC   [0xA]              (0226)    rrc   [(ADCINCVR_4_iResult + LowByte)]
                                        (0227) 
                                        (0228)    ;@PSoC_UserCode_BODY_3@ (Do not change this line.)
                                        (0229)    ;---------------------------------------------------
                                        (0230)    ; Data is ready at this point.
                                        (0231)    ; If processing Data at Interrupt level - add
                                        (0232)    ; User Code to handle the data below this banner
                                        (0233)    ;---------------------------------------------------
                                        (0234)    ;   NOTE: interrupt service routines must preserve
                                        (0235)    ;   the values of the A and X CPU registers. At this
                                        (0236)    ;   point A is already preserved and will be restored;
                                        (0237)    ;   however, if you use X, you must take care of it
                                        (0238)    ;   here!
                                        (0239) 
                                        (0240)    ;---------------------------------------------------
                                        (0241)    ; Insert your custom code above this banner
                                        (0242)    ;---------------------------------------------------
                                        (0243)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0244) 
05CD: 18       POP   A                  (0245)    pop   A                                       ; Restore A, not used any more
                                        (0246) 
05CE: 2E 0B 10 OR    [0xB],0x10         (0247)    or    [ADCINCVR_4_bfStatus],ADCINCVR_4_fDATA_READY  ; Set Data ready bit
                                        (0248) 
05D1: 47 0C FF TST   [0xC],0xFF         (0249)    tst   [ADCINCVR_4_bSampC], ffh                ; If sample_counter == 0 -->> continuous data collection
05D4: A0 17    JZ    0x05EC             (0250)    jz    ADCINCVR_4_END_PWM16_ISR
                                        (0251) 
05D6: 7A 0C    DEC   [0xC]              (0252)    dec   [ADCINCVR_4_bSampC]                     ; Dec sample counter and check for zero
05D8: B0 13    JNZ   0x05EC             (0253)    jnz   ADCINCVR_4_END_PWM16_ISR
                                        (0254) 
                                        (0255)    ;**********************************************
                                        (0256)    ; Turn off ADC
                                        (0257)    ;**********************************************
05DA: 41 4B FE AND   REG[0x4B],0xFE     (0258)    and   reg[ADCINCVR_4_fPWM_LSB_CR0], ~ADCINCVR_4_fDBLK_ENABLE     ; Disable the PWM
05DD: 41 37 FE AND   REG[0x37],0xFE     (0259)    and   reg[ADCINCVR_4_bCounter_CR0], ~ADCINCVR_4_fDBLK_ENABLE           ; Disable the Counter
                                        (0260) IF ADCINCVR_4_NoAZ
05E0: 43 8E 20 OR    REG[0x8E],0x20     (0261)    or    reg[ADCINCVR_4_bfAtoDcr2], ADCINCVR_4_fAutoZero       ; Put the Integrator into Autozero mode
                                        (0262) ENDIF
05E3: 43 8F 10 OR    REG[0x8F],0x10     (0263)    or    reg[ADCINCVR_4_bfAtoDcr3], ADCINCVR_4_fFSW0           ; Put Integrator into reset
05E6: 41 DF F7 AND   REG[0xDF],0xF7     (0264)    and   reg[ADCINCVR_4_bfPWM16_INT_REG], ~ADCINCVR_4_bfPWM16_Mask      ; Disable interrupts
05E9: 41 E1 DF AND   REG[0xE1],0xDF     (0265)    and   reg[ADCINCVR_4_bfCounter_INT_REG], ~ADCINCVR_4_bfCounter_Mask
                                        (0266) 
                                        (0267) ADCINCVR_4_END_PWM16_ISR:
05EC: 7E       RETI                     (0268)    reti
(0269) 
(0270) ; End of File ADCINCVR_4INT.asm
FILE: lib\adcincvr_3int.asm
                                        (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME:   ADCINCVR_3INT.asm
                                        (0004) ;;  Version: 3.1, Updated on 2009/10/15 at 17:11:37
                                        (0005) ;;  Generated by PSoC Designer 5.0.1127.0
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: ADCINCVR Interrupt Service Routines
                                        (0008) ;;-----------------------------------------------------------------------------
                                        (0009) ;;  Copyright (c) Cypress Semiconductor 2009. All Rights Reserved.
                                        (0010) ;;*****************************************************************************
                                        (0011) ;;*****************************************************************************
                                        (0012) 
                                        (0013) include "m8c.inc"
                                        (0014) include "memory.inc"
                                        (0015) include "ADCINCVR_3.inc"
                                        (0016) 
                                        (0017) ;-----------------------------------------------
                                        (0018) ;  Global Symbols
                                        (0019) ;-----------------------------------------------
                                        (0020) export _ADCINCVR_3_CNT_ISR
                                        (0021) export _ADCINCVR_3_PWM16_ISR
                                        (0022) export  ADCINCVR_3_cCounterU
                                        (0023) export _ADCINCVR_3_iResult
                                        (0024) export  ADCINCVR_3_iResult
                                        (0025) export _ADCINCVR_3_bfStatus
                                        (0026) export  ADCINCVR_3_bfStatus
                                        (0027) export  ADCINCVR_3_bSampC
                                        (0028) 
                                        (0029) ;-----------------------------------------------
                                        (0030) ; Variable Allocation
                                        (0031) ;-----------------------------------------------
                                        (0032) AREA InterruptRAM(RAM, REL, CON)
                                        (0033) 
                                        (0034)  ADCINCVR_3_cCounterU:     BLK   1  ;The Upper byte of the Counter
                                        (0035) _ADCINCVR_3_iResult:
                                        (0036)  ADCINCVR_3_iResult:       BLK   2  ;A/D value
                                        (0037) _ADCINCVR_3_bfStatus:
                                        (0038)  ADCINCVR_3_bfStatus:      BLK   1  ;Data Valid Flag
                                        (0039)  ADCINCVR_3_bSampC:        BLK   1  ;# of times to run A/D
                                        (0040) 
                                        (0041) 
                                        (0042) ;-----------------------------------------------
                                        (0043) ;  EQUATES and TABLES
                                        (0044) ;-----------------------------------------------
                                        (0045) LowByte:   equ 1
                                        (0046) HighByte:  equ 0
                                        (0047) 
                                        (0048) 
                                        (0049) ;@PSoC_UserCode_INIT@ (Do not change this line.)
                                        (0050) ;---------------------------------------------------
                                        (0051) ; Insert your custom declarations below this banner
                                        (0052) ;---------------------------------------------------
                                        (0053) 
                                        (0054) ;------------------------
                                        (0055) ; Includes
                                        (0056) ;------------------------
                                        (0057) 
                                        (0058) 	
                                        (0059) ;------------------------
                                        (0060) ;  Constant Definitions
                                        (0061) ;------------------------
                                        (0062) 
                                        (0063) 
                                        (0064) ;------------------------
                                        (0065) ; Variable Allocation
                                        (0066) ;------------------------
                                        (0067) 
                                        (0068) 
                                        (0069) ;---------------------------------------------------
                                        (0070) ; Insert your custom declarations above this banner
                                        (0071) ;---------------------------------------------------
                                        (0072) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0073) 
                                        (0074) AREA UserModules (ROM, REL)
                                        (0075) 
                                        (0076) .LITERAL
                                        (0077) ADCINCVR_3MaxNegX4Table:
                                        (0078) ; Bits  7    8    9   10   11   12   13
                                        (0079)    DB  FFh, FEh, FCh, F8h, F0h, E0h, C0h
                                        (0080) 
                                        (0081) ADCINCVR_3MaxPosX4Table:
                                        (0082) IF (ADCINCVR_3_DATA_FORMAT)
                                        (0083) ; Bits (signed)    7    8    9   10   11   12   13
                                        (0084)               DB  01h, 02h, 04h, 08h, 10h, 20h, 40h
                                        (0085) ELSE
                                        (0086) ; Bits (unsigned)  7    8    9   10   11   12   13
                                        (0087)               DB  02h, 04h, 08h, 10h, 20h, 40h, 80h
                                        (0088) 
                                        (0089)  ENDIF
                                        (0090) .ENDLITERAL
                                        (0091) 
                                        (0092) ;-----------------------------------------------------------------------------
                                        (0093) ;  FUNCTION NAME: _ADCINCVR_3_CNT_ISR (Counter8 Interrupt)
                                        (0094) ;
                                        (0095) ;
                                        (0096) ;  DESCRIPTION:
                                        (0097) ;     Increment the upper (software) half on the counter whenever the
                                        (0098) ;     lower (hardware) half of the counter underflows.  This counter
                                        (0099) ;     should start out at the most negative value (0xFF).
                                        (0100) ;
                                        (0101) ;-----------------------------------------------------------------------------
                                        (0102) ;
                                        (0103) _ADCINCVR_3_CNT_ISR:

(0104)    inc [ADCINCVR_3_cCounterU]
                                        (0105)    ;@PSoC_UserCode_BODY_1@ (Do not change this line.)
                                        (0106)    ;---------------------------------------------------
                                        (0107)    ; Insert your custom code below this banner
                                        (0108)    ;---------------------------------------------------
                                        (0109)    ;   NOTE: interrupt service routines must preserve
                                        (0110)    ;   the values of the A and X CPU registers.
                                        (0111) 
                                        (0112)    ;---------------------------------------------------
                                        (0113)    ; Insert your custom code above this banner
                                        (0114)    ;---------------------------------------------------
                                        (0115)    ;@PSoC_UserCode_END@ (Do not change this line.)
05FC: 0D 7E    ADC   [X+126],A          (0116)    reti
                                        (0117) 
                                        (0118) 
                                        (0119) ;-----------------------------------------------------------------------------
                                        (0120) ;  FUNCTION NAME: _ADCINCVR_3_PWM16_ISR  (PWM16 Interrupt)
                                        (0121) ;
                                        (0122) ;  DESCRIPTION:
                                        (0123) ;     This ISR is called when the ADC has completed and integrate cycle.
                                        (0124) ;     The ADC value is calculated and stored in a global location before
                                        (0125) ;     the end of the ISR.
                                        (0126) ;
                                        (0127) ;-----------------------------------------------------------------------------
                                        (0128) ;
                                        (0129) _ADCINCVR_3_PWM16_ISR:
05FE: 41 33 FE AND   REG[0x33],0xFE     (0130)    and   reg[ADCINCVR_3_bCounter_CR0], ~ADCINCVR_3_fDBLK_ENABLE  ; Disable Counter
                                        (0131) IF ADCINCVR_3_NoAZ
0601: 43 8A 20 OR    REG[0x8A],0x20     (0132)    or    reg[ADCINCVR_3_bfAtoDcr2], ADCINCVR_3_fAutoZero      ; Put Integrator in AutoZero
                                        (0133) ENDIF
0604: 43 8B 10 OR    REG[0x8B],0x10     (0134)    or   reg[ADCINCVR_3_bfAtoDcr3],ADCINCVR_3_fFSW0         ; Put Integrator in reset
                                        (0135) 
                                        (0136)                                                            ; Enable interrupts for a short period of time just in case.
                                        (0137)                                                            ; Make sure we didn't have a counter interrupt ready to fire
0607: 71 01    OR    F,0x1              (0138)    M8C_EnableGInt
0609: 40       NOP                      (0139)    nop                                                     ; Wait a couple cycles
060A: 70 FE    AND   F,0xFE             (0140)    M8C_DisableGInt                                         ; Disable interrupt, read to complete processing
060C: 08       PUSH  A                  (0141)    push  A                                                 ; Save the Accumulator
060D: 5D 30    MOV   A,REG[0x30]        (0142)    mov   A,reg[ADCINCVR_3_bCount]                          ; Read counter value  (Bogus read puts value in Period register)
060F: 5D 32    MOV   A,REG[0x32]        (0143)    mov   A,reg[ADCINCVR_3_bCompare]                        ; Read counter value
0611: 78       DEC   A                  (0144)    dec   A                                                 ; Decrement by one to make sure we didn't miss a count
0612: 73       CPL   A                  (0145)    cpl   A                                                 ; Invert the value
0613: D0 03    JNC   0x0617             (0146)    jnc   ADCINCVR_3_INT_CALCV                              ; if carry, then inc MSB as well
0615: 76 0D    INC   [0xD]              (0147)    inc   [ADCINCVR_3_cCounterU]
                                        (0148) ADCINCVR_3_INT_CALCV:
0617: 53 0F    MOV   [iles],A           (0149)    mov   [(ADCINCVR_3_iResult + LowByte)], A               ; Store LSB value
0619: 51 0D    MOV   A,[0xD]            (0150)    mov   A, [ADCINCVR_3_cCounterU]                         ; Store MSB from temp counter
061B: 53 0E    MOV   [0xE],A            (0151)    mov   [(ADCINCVR_3_iResult + HighByte)], A
                                        (0152)                                                            ; The new value has been stored,
                                        (0153)                                                            ; so get counters ready for next reading first.
061D: 62 31 FF MOV   REG[0x31],0xFF     (0154)    mov   reg[ADCINCVR_3_bPeriod], ffh                      ; Initialize counter to FF - Set to overflow after 256 counts
0620: 43 33 01 OR    REG[0x33],0x1      (0155)    or    reg[ADCINCVR_3_bCounter_CR0],ADCINCVR_3_fDBLK_ENABLE  ; Enable Counter
                                        (0156) 
                                        (0157) IF (ADCINCVR_3_DATA_FORMAT)                                ; Only check for Negative numbers if SIGNED result
                                        (0158)    mov   A, [ADCINCVR_3_bfStatus]                          ; Get Status with Resolution
                                        (0159)    and   A, ADCINCVR_3_bRES_MASK                           ; Mask of resolution
                                        (0160)    index ADCINCVR_3MaxNegX4Table                           ; Get Maximum negative value from table
                                        (0161)    mov   [ADCINCVR_3_cCounterU], A                         ; Place result back into MSB of counter
                                        (0162) ELSE
0623: 55 0D 00 MOV   [0xD],0x0          (0163)    mov   [ADCINCVR_3_cCounterU], 00h                       ; Place result back into MSB of counter
                                        (0164) ENDIF
                                        (0165) 
                                        (0166)    ;@PSoC_UserCode_BODY_2@ (Do not change this line.)
                                        (0167)    ;---------------------------------------------------
                                        (0168)    ; If the input is muxed with multiple inputs
                                        (0169)    ; this is a good place to change inputs.
                                        (0170)    ; Insert your custom code below this banner
                                        (0171)    ;---------------------------------------------------
                                        (0172)    ;   NOTE: interrupt service routines must preserve
                                        (0173)    ;   the values of the A and X CPU registers. At this
                                        (0174)    ;   point A is already preserved and will be restored;
                                        (0175)    ;   however, if you use X, you must take care of it
                                        (0176)    ;   here!
                                        (0177) 
                                        (0178)    ;---------------------------------------------------
                                        (0179)    ; Insert your custom code above this banner
                                        (0180)    ;---------------------------------------------------
                                        (0181)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0182) 
0626: 41 8B EF AND   REG[0x8B],0xEF     (0183)    and   reg[ADCINCVR_3_bfAtoDcr3],~ADCINCVR_3_fFSW0       ; Take Integrator out of reset
                                        (0184) IF ADCINCVR_3_NoAZ
0629: 41 8A DF AND   REG[0x8A],0xDF     (0185)    and   reg[ADCINCVR_3_bfAtoDcr2],~ADCINCVR_3_fAutoZero   ; Take Integrator out of AutoZero
                                        (0186) ENDIF
                                        (0187) 
                                        (0188)    ;****************************************************************************
                                        (0189)    ;M8C_EnableGInt            ; May want to re-enable interrupts at this point,
                                        (0190)    ;                          ; if stack space isn't at a premium.
                                        (0191)    ; NOTE:  this will make system more responsive but, will increase the
                                        (0192)    ;        overall processing time of the A/D calctime.  If an interrupt is
                                        (0193)    ;        taken, it must return within the specified CalcTime to guarantee
                                        (0194)    ;        successful acquisition of the next byte.
                                        (0195)    ;****************************************************************************
                                        (0196) IF (ADCINCVR_3_DATA_FORMAT)                      ; Only check for Negative numbers if SIGNED result
                                        (0197) 
                                        (0198)                                                  ; Negative Overflow Check
                                        (0199)    tst   [(ADCINCVR_3_iResult + HighByte)],80h
                                        (0200)    jnz   ADCINCVR_3_NOT_POVFL2
                                        (0201) 
                                        (0202) ENDIF
                                        (0203)                                                  ; Postive Overflow Check
                                        (0204)                                                  ; Get MSB of Max Positive value x4 + 1
062C: 51 10    MOV   A,[iles+1]         (0205)    mov   A,[ADCINCVR_3_bfStatus]                 ; Get Status with Resolution
062E: 21 0F    AND   A,0xF              (0206)    and   A,ADCINCVR_3_bRES_MASK                  ; Mask of resolution normalized to 0
0630: FF C2    INDEX 0x05F4             (0207)    index ADCINCVR_3MaxPosX4Table                 ; Get Maximum positive value x4 + 1 from table
0632: 08       PUSH  A                  (0208)    push  A
0633: 22 0E    AND   A,[0xE]            (0209)    and   A, [(ADCINCVR_3_iResult + HighByte)]
0635: A0 0B    JZ    0x0641             (0210)    jz    ADCINCVR_3_NOT_POVFL
                                        (0211)                                                  ; Positive overflow, fix it - set to Max Positive + 1
0637: 18       POP   A                  (0212)    pop   A
0638: 11 01    SUB   A,0x1              (0213)    sub   A, 01h
                                        (0214) 
                                        (0215)                                                  ; Force most positive * 4 into result
063A: 53 0E    MOV   [0xE],A            (0216)    mov   [(ADCINCVR_3_iResult + HighByte)], A
063C: 55 0F FF MOV   [iles],0xFF        (0217)    mov   [(ADCINCVR_3_iResult + LowByte)], ffh
063F: 80 02    JMP   0x0642             (0218)    jmp   ADCINCVR_3_NOT_POVFL2
                                        (0219) ADCINCVR_3_NOT_POVFL:
0641: 18       POP   A                  (0220)    pop   A
                                        (0221) 
                                        (0222) ADCINCVR_3_NOT_POVFL2:
0642: 68 0E    ASR   [0xE]              (0223)    asr   [(ADCINCVR_3_iResult + HighByte)]       ; Shift MSB and LSB right twice to divide by four
0644: 6E 0F    RRC   [iles]             (0224)    rrc   [(ADCINCVR_3_iResult + LowByte)]        ; Remember digital clock 4 times analog clock
0646: 68 0E    ASR   [0xE]              (0225)    asr   [(ADCINCVR_3_iResult + HighByte)]
0648: 6E 0F    RRC   [iles]             (0226)    rrc   [(ADCINCVR_3_iResult + LowByte)]
                                        (0227) 
                                        (0228)    ;@PSoC_UserCode_BODY_3@ (Do not change this line.)
                                        (0229)    ;---------------------------------------------------
                                        (0230)    ; Data is ready at this point.
                                        (0231)    ; If processing Data at Interrupt level - add
                                        (0232)    ; User Code to handle the data below this banner
                                        (0233)    ;---------------------------------------------------
                                        (0234)    ;   NOTE: interrupt service routines must preserve
                                        (0235)    ;   the values of the A and X CPU registers. At this
                                        (0236)    ;   point A is already preserved and will be restored;
                                        (0237)    ;   however, if you use X, you must take care of it
                                        (0238)    ;   here!
                                        (0239) 
                                        (0240)    ;---------------------------------------------------
                                        (0241)    ; Insert your custom code above this banner
                                        (0242)    ;---------------------------------------------------
                                        (0243)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0244) 
064A: 18       POP   A                  (0245)    pop   A                                       ; Restore A, not used any more
                                        (0246) 
064B: 2E 10 10 OR    [iles+1],0x10      (0247)    or    [ADCINCVR_3_bfStatus],ADCINCVR_3_fDATA_READY  ; Set Data ready bit
                                        (0248) 
064E: 47 11 FF TST   [iles+2],0xFF      (0249)    tst   [ADCINCVR_3_bSampC], ffh                ; If sample_counter == 0 -->> continuous data collection
0651: A0 17    JZ    0x0669             (0250)    jz    ADCINCVR_3_END_PWM16_ISR
                                        (0251) 
0653: 7A 11    DEC   [iles+2]           (0252)    dec   [ADCINCVR_3_bSampC]                     ; Dec sample counter and check for zero
0655: B0 13    JNZ   0x0669             (0253)    jnz   ADCINCVR_3_END_PWM16_ISR
                                        (0254) 
                                        (0255)    ;**********************************************
                                        (0256)    ; Turn off ADC
                                        (0257)    ;**********************************************
0657: 41 43 FE AND   REG[0x43],0xFE     (0258)    and   reg[ADCINCVR_3_fPWM_LSB_CR0], ~ADCINCVR_3_fDBLK_ENABLE     ; Disable the PWM
065A: 41 33 FE AND   REG[0x33],0xFE     (0259)    and   reg[ADCINCVR_3_bCounter_CR0], ~ADCINCVR_3_fDBLK_ENABLE           ; Disable the Counter
                                        (0260) IF ADCINCVR_3_NoAZ
065D: 43 8A 20 OR    REG[0x8A],0x20     (0261)    or    reg[ADCINCVR_3_bfAtoDcr2], ADCINCVR_3_fAutoZero       ; Put the Integrator into Autozero mode
                                        (0262) ENDIF
0660: 43 8B 10 OR    REG[0x8B],0x10     (0263)    or    reg[ADCINCVR_3_bfAtoDcr3], ADCINCVR_3_fFSW0           ; Put Integrator into reset
0663: 41 DF FD AND   REG[0xDF],0xFD     (0264)    and   reg[ADCINCVR_3_bfPWM16_INT_REG], ~ADCINCVR_3_bfPWM16_Mask      ; Disable interrupts
0666: 41 E1 EF AND   REG[0xE1],0xEF     (0265)    and   reg[ADCINCVR_3_bfCounter_INT_REG], ~ADCINCVR_3_bfCounter_Mask
                                        (0266) 
                                        (0267) ADCINCVR_3_END_PWM16_ISR:
0669: 7E       RETI                     (0268)    reti
(0269) 
(0270) ; End of File ADCINCVR_3INT.asm
FILE: lib\adcincvr_2int.asm
                                        (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME:   ADCINCVR_2INT.asm
                                        (0004) ;;  Version: 3.1, Updated on 2009/10/15 at 17:11:37
                                        (0005) ;;  Generated by PSoC Designer 5.0.1127.0
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: ADCINCVR Interrupt Service Routines
                                        (0008) ;;-----------------------------------------------------------------------------
                                        (0009) ;;  Copyright (c) Cypress Semiconductor 2009. All Rights Reserved.
                                        (0010) ;;*****************************************************************************
                                        (0011) ;;*****************************************************************************
                                        (0012) 
                                        (0013) include "m8c.inc"
                                        (0014) include "memory.inc"
                                        (0015) include "ADCINCVR_2.inc"
                                        (0016) 
                                        (0017) ;-----------------------------------------------
                                        (0018) ;  Global Symbols
                                        (0019) ;-----------------------------------------------
                                        (0020) export _ADCINCVR_2_CNT_ISR
                                        (0021) export _ADCINCVR_2_PWM16_ISR
                                        (0022) export  ADCINCVR_2_cCounterU
                                        (0023) export _ADCINCVR_2_iResult
                                        (0024) export  ADCINCVR_2_iResult
                                        (0025) export _ADCINCVR_2_bfStatus
                                        (0026) export  ADCINCVR_2_bfStatus
                                        (0027) export  ADCINCVR_2_bSampC
                                        (0028) 
                                        (0029) ;-----------------------------------------------
                                        (0030) ; Variable Allocation
                                        (0031) ;-----------------------------------------------
                                        (0032) AREA InterruptRAM(RAM, REL, CON)
                                        (0033) 
                                        (0034)  ADCINCVR_2_cCounterU:     BLK   1  ;The Upper byte of the Counter
                                        (0035) _ADCINCVR_2_iResult:
                                        (0036)  ADCINCVR_2_iResult:       BLK   2  ;A/D value
                                        (0037) _ADCINCVR_2_bfStatus:
                                        (0038)  ADCINCVR_2_bfStatus:      BLK   1  ;Data Valid Flag
                                        (0039)  ADCINCVR_2_bSampC:        BLK   1  ;# of times to run A/D
                                        (0040) 
                                        (0041) 
                                        (0042) ;-----------------------------------------------
                                        (0043) ;  EQUATES and TABLES
                                        (0044) ;-----------------------------------------------
                                        (0045) LowByte:   equ 1
                                        (0046) HighByte:  equ 0
                                        (0047) 
                                        (0048) 
                                        (0049) ;@PSoC_UserCode_INIT@ (Do not change this line.)
                                        (0050) ;---------------------------------------------------
                                        (0051) ; Insert your custom declarations below this banner
                                        (0052) ;---------------------------------------------------
                                        (0053) 
                                        (0054) ;------------------------
                                        (0055) ; Includes
                                        (0056) ;------------------------
                                        (0057) 
                                        (0058) 	
                                        (0059) ;------------------------
                                        (0060) ;  Constant Definitions
                                        (0061) ;------------------------
                                        (0062) 
                                        (0063) 
                                        (0064) ;------------------------
                                        (0065) ; Variable Allocation
                                        (0066) ;------------------------
                                        (0067) 
                                        (0068) 
                                        (0069) ;---------------------------------------------------
                                        (0070) ; Insert your custom declarations above this banner
                                        (0071) ;---------------------------------------------------
                                        (0072) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0073) 
                                        (0074) AREA UserModules (ROM, REL)
                                        (0075) 
                                        (0076) .LITERAL
                                        (0077) ADCINCVR_2MaxNegX4Table:
                                        (0078) ; Bits  7    8    9   10   11   12   13
                                        (0079)    DB  FFh, FEh, FCh, F8h, F0h, E0h, C0h
                                        (0080) 
                                        (0081) ADCINCVR_2MaxPosX4Table:
                                        (0082) IF (ADCINCVR_2_DATA_FORMAT)
                                        (0083) ; Bits (signed)    7    8    9   10   11   12   13
                                        (0084)               DB  01h, 02h, 04h, 08h, 10h, 20h, 40h
                                        (0085) ELSE
                                        (0086) ; Bits (unsigned)  7    8    9   10   11   12   13
                                        (0087)               DB  02h, 04h, 08h, 10h, 20h, 40h, 80h
                                        (0088) 
                                        (0089)  ENDIF
                                        (0090) .ENDLITERAL
                                        (0091) 
                                        (0092) ;-----------------------------------------------------------------------------
                                        (0093) ;  FUNCTION NAME: _ADCINCVR_2_CNT_ISR (Counter8 Interrupt)
                                        (0094) ;
                                        (0095) ;
                                        (0096) ;  DESCRIPTION:
                                        (0097) ;     Increment the upper (software) half on the counter whenever the
                                        (0098) ;     lower (hardware) half of the counter underflows.  This counter
                                        (0099) ;     should start out at the most negative value (0xFF).
                                        (0100) ;
                                        (0101) ;-----------------------------------------------------------------------------
                                        (0102) ;
                                        (0103) _ADCINCVR_2_CNT_ISR:

(0104)    inc [ADCINCVR_2_cCounterU]
                                        (0105)    ;@PSoC_UserCode_BODY_1@ (Do not change this line.)
                                        (0106)    ;---------------------------------------------------
                                        (0107)    ; Insert your custom code below this banner
                                        (0108)    ;---------------------------------------------------
                                        (0109)    ;   NOTE: interrupt service routines must preserve
                                        (0110)    ;   the values of the A and X CPU registers.
                                        (0111) 
                                        (0112)    ;---------------------------------------------------
                                        (0113)    ; Insert your custom code above this banner
                                        (0114)    ;---------------------------------------------------
                                        (0115)    ;@PSoC_UserCode_END@ (Do not change this line.)
0679: 12 7E    SUB   A,[0x7E]           (0116)    reti
                                        (0117) 
                                        (0118) 
                                        (0119) ;-----------------------------------------------------------------------------
                                        (0120) ;  FUNCTION NAME: _ADCINCVR_2_PWM16_ISR  (PWM16 Interrupt)
                                        (0121) ;
                                        (0122) ;  DESCRIPTION:
                                        (0123) ;     This ISR is called when the ADC has completed and integrate cycle.
                                        (0124) ;     The ADC value is calculated and stored in a global location before
                                        (0125) ;     the end of the ISR.
                                        (0126) ;
                                        (0127) ;-----------------------------------------------------------------------------
                                        (0128) ;
                                        (0129) _ADCINCVR_2_PWM16_ISR:
067B: 41 2F FE AND   REG[0x2F],0xFE     (0130)    and   reg[ADCINCVR_2_bCounter_CR0], ~ADCINCVR_2_fDBLK_ENABLE  ; Disable Counter
                                        (0131) IF ADCINCVR_2_NoAZ
067E: 43 86 20 OR    REG[0x86],0x20     (0132)    or    reg[ADCINCVR_2_bfAtoDcr2], ADCINCVR_2_fAutoZero      ; Put Integrator in AutoZero
                                        (0133) ENDIF
0681: 43 87 10 OR    REG[0x87],0x10     (0134)    or   reg[ADCINCVR_2_bfAtoDcr3],ADCINCVR_2_fFSW0         ; Put Integrator in reset
                                        (0135) 
                                        (0136)                                                            ; Enable interrupts for a short period of time just in case.
                                        (0137)                                                            ; Make sure we didn't have a counter interrupt ready to fire
0684: 71 01    OR    F,0x1              (0138)    M8C_EnableGInt
0686: 40       NOP                      (0139)    nop                                                     ; Wait a couple cycles
0687: 70 FE    AND   F,0xFE             (0140)    M8C_DisableGInt                                         ; Disable interrupt, read to complete processing
0689: 08       PUSH  A                  (0141)    push  A                                                 ; Save the Accumulator
068A: 5D 2C    MOV   A,REG[0x2C]        (0142)    mov   A,reg[ADCINCVR_2_bCount]                          ; Read counter value  (Bogus read puts value in Period register)
068C: 5D 2E    MOV   A,REG[0x2E]        (0143)    mov   A,reg[ADCINCVR_2_bCompare]                        ; Read counter value
068E: 78       DEC   A                  (0144)    dec   A                                                 ; Decrement by one to make sure we didn't miss a count
068F: 73       CPL   A                  (0145)    cpl   A                                                 ; Invert the value
0690: D0 03    JNC   0x0694             (0146)    jnc   ADCINCVR_2_INT_CALCV                              ; if carry, then inc MSB as well
0692: 76 12    INC   [iles+3]           (0147)    inc   [ADCINCVR_2_cCounterU]
                                        (0148) ADCINCVR_2_INT_CALCV:
0694: 53 14    MOV   [iles+5],A         (0149)    mov   [(ADCINCVR_2_iResult + LowByte)], A               ; Store LSB value
0696: 51 12    MOV   A,[iles+3]         (0150)    mov   A, [ADCINCVR_2_cCounterU]                         ; Store MSB from temp counter
0698: 53 13    MOV   [iles+4],A         (0151)    mov   [(ADCINCVR_2_iResult + HighByte)], A
                                        (0152)                                                            ; The new value has been stored,
                                        (0153)                                                            ; so get counters ready for next reading first.
069A: 62 2D FF MOV   REG[0x2D],0xFF     (0154)    mov   reg[ADCINCVR_2_bPeriod], ffh                      ; Initialize counter to FF - Set to overflow after 256 counts
069D: 43 2F 01 OR    REG[0x2F],0x1      (0155)    or    reg[ADCINCVR_2_bCounter_CR0],ADCINCVR_2_fDBLK_ENABLE  ; Enable Counter
                                        (0156) 
                                        (0157) IF (ADCINCVR_2_DATA_FORMAT)                                ; Only check for Negative numbers if SIGNED result
                                        (0158)    mov   A, [ADCINCVR_2_bfStatus]                          ; Get Status with Resolution
                                        (0159)    and   A, ADCINCVR_2_bRES_MASK                           ; Mask of resolution
                                        (0160)    index ADCINCVR_2MaxNegX4Table                           ; Get Maximum negative value from table
                                        (0161)    mov   [ADCINCVR_2_cCounterU], A                         ; Place result back into MSB of counter
                                        (0162) ELSE
06A0: 55 12 00 MOV   [iles+3],0x0       (0163)    mov   [ADCINCVR_2_cCounterU], 00h                       ; Place result back into MSB of counter
                                        (0164) ENDIF
                                        (0165) 
                                        (0166)    ;@PSoC_UserCode_BODY_2@ (Do not change this line.)
                                        (0167)    ;---------------------------------------------------
                                        (0168)    ; If the input is muxed with multiple inputs
                                        (0169)    ; this is a good place to change inputs.
                                        (0170)    ; Insert your custom code below this banner
                                        (0171)    ;---------------------------------------------------
                                        (0172)    ;   NOTE: interrupt service routines must preserve
                                        (0173)    ;   the values of the A and X CPU registers. At this
                                        (0174)    ;   point A is already preserved and will be restored;
                                        (0175)    ;   however, if you use X, you must take care of it
                                        (0176)    ;   here!
                                        (0177) 
                                        (0178)    ;---------------------------------------------------
                                        (0179)    ; Insert your custom code above this banner
                                        (0180)    ;---------------------------------------------------
                                        (0181)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0182) 
06A3: 41 87 EF AND   REG[0x87],0xEF     (0183)    and   reg[ADCINCVR_2_bfAtoDcr3],~ADCINCVR_2_fFSW0       ; Take Integrator out of reset
                                        (0184) IF ADCINCVR_2_NoAZ
06A6: 41 86 DF AND   REG[0x86],0xDF     (0185)    and   reg[ADCINCVR_2_bfAtoDcr2],~ADCINCVR_2_fAutoZero   ; Take Integrator out of AutoZero
                                        (0186) ENDIF
                                        (0187) 
                                        (0188)    ;****************************************************************************
                                        (0189)    ;M8C_EnableGInt            ; May want to re-enable interrupts at this point,
                                        (0190)    ;                          ; if stack space isn't at a premium.
                                        (0191)    ; NOTE:  this will make system more responsive but, will increase the
                                        (0192)    ;        overall processing time of the A/D calctime.  If an interrupt is
                                        (0193)    ;        taken, it must return within the specified CalcTime to guarantee
                                        (0194)    ;        successful acquisition of the next byte.
                                        (0195)    ;****************************************************************************
                                        (0196) IF (ADCINCVR_2_DATA_FORMAT)                      ; Only check for Negative numbers if SIGNED result
                                        (0197) 
                                        (0198)                                                  ; Negative Overflow Check
                                        (0199)    tst   [(ADCINCVR_2_iResult + HighByte)],80h
                                        (0200)    jnz   ADCINCVR_2_NOT_POVFL2
                                        (0201) 
                                        (0202) ENDIF
                                        (0203)                                                  ; Postive Overflow Check
                                        (0204)                                                  ; Get MSB of Max Positive value x4 + 1
06A9: 51 15    MOV   A,[iles+6]         (0205)    mov   A,[ADCINCVR_2_bfStatus]                 ; Get Status with Resolution
06AB: 21 0F    AND   A,0xF              (0206)    and   A,ADCINCVR_2_bRES_MASK                  ; Mask of resolution normalized to 0
06AD: FF C2    INDEX 0x0671             (0207)    index ADCINCVR_2MaxPosX4Table                 ; Get Maximum positive value x4 + 1 from table
06AF: 08       PUSH  A                  (0208)    push  A
06B0: 22 13    AND   A,[iles+4]         (0209)    and   A, [(ADCINCVR_2_iResult + HighByte)]
06B2: A0 0B    JZ    0x06BE             (0210)    jz    ADCINCVR_2_NOT_POVFL
                                        (0211)                                                  ; Positive overflow, fix it - set to Max Positive + 1
06B4: 18       POP   A                  (0212)    pop   A
06B5: 11 01    SUB   A,0x1              (0213)    sub   A, 01h
                                        (0214) 
                                        (0215)                                                  ; Force most positive * 4 into result
06B7: 53 13    MOV   [iles+4],A         (0216)    mov   [(ADCINCVR_2_iResult + HighByte)], A
06B9: 55 14 FF MOV   [iles+5],0xFF      (0217)    mov   [(ADCINCVR_2_iResult + LowByte)], ffh
06BC: 80 02    JMP   0x06BF             (0218)    jmp   ADCINCVR_2_NOT_POVFL2
                                        (0219) ADCINCVR_2_NOT_POVFL:
06BE: 18       POP   A                  (0220)    pop   A
                                        (0221) 
                                        (0222) ADCINCVR_2_NOT_POVFL2:
06BF: 68 13    ASR   [iles+4]           (0223)    asr   [(ADCINCVR_2_iResult + HighByte)]       ; Shift MSB and LSB right twice to divide by four
06C1: 6E 14    RRC   [iles+5]           (0224)    rrc   [(ADCINCVR_2_iResult + LowByte)]        ; Remember digital clock 4 times analog clock
06C3: 68 13    ASR   [iles+4]           (0225)    asr   [(ADCINCVR_2_iResult + HighByte)]
06C5: 6E 14    RRC   [iles+5]           (0226)    rrc   [(ADCINCVR_2_iResult + LowByte)]
                                        (0227) 
                                        (0228)    ;@PSoC_UserCode_BODY_3@ (Do not change this line.)
                                        (0229)    ;---------------------------------------------------
                                        (0230)    ; Data is ready at this point.
                                        (0231)    ; If processing Data at Interrupt level - add
                                        (0232)    ; User Code to handle the data below this banner
                                        (0233)    ;---------------------------------------------------
                                        (0234)    ;   NOTE: interrupt service routines must preserve
                                        (0235)    ;   the values of the A and X CPU registers. At this
                                        (0236)    ;   point A is already preserved and will be restored;
                                        (0237)    ;   however, if you use X, you must take care of it
                                        (0238)    ;   here!
                                        (0239) 
                                        (0240)    ;---------------------------------------------------
                                        (0241)    ; Insert your custom code above this banner
                                        (0242)    ;---------------------------------------------------
                                        (0243)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0244) 
06C7: 18       POP   A                  (0245)    pop   A                                       ; Restore A, not used any more
                                        (0246) 
06C8: 2E 15 10 OR    [iles+6],0x10      (0247)    or    [ADCINCVR_2_bfStatus],ADCINCVR_2_fDATA_READY  ; Set Data ready bit
                                        (0248) 
06CB: 47 16 FF TST   [iles+7],0xFF      (0249)    tst   [ADCINCVR_2_bSampC], ffh                ; If sample_counter == 0 -->> continuous data collection
06CE: A0 17    JZ    0x06E6             (0250)    jz    ADCINCVR_2_END_PWM16_ISR
                                        (0251) 
06D0: 7A 16    DEC   [iles+7]           (0252)    dec   [ADCINCVR_2_bSampC]                     ; Dec sample counter and check for zero
06D2: B0 13    JNZ   0x06E6             (0253)    jnz   ADCINCVR_2_END_PWM16_ISR
                                        (0254) 
                                        (0255)    ;**********************************************
                                        (0256)    ; Turn off ADC
                                        (0257)    ;**********************************************
06D4: 41 3B FE AND   REG[0x3B],0xFE     (0258)    and   reg[ADCINCVR_2_fPWM_LSB_CR0], ~ADCINCVR_2_fDBLK_ENABLE     ; Disable the PWM
06D7: 41 2F FE AND   REG[0x2F],0xFE     (0259)    and   reg[ADCINCVR_2_bCounter_CR0], ~ADCINCVR_2_fDBLK_ENABLE           ; Disable the Counter
                                        (0260) IF ADCINCVR_2_NoAZ
06DA: 43 86 20 OR    REG[0x86],0x20     (0261)    or    reg[ADCINCVR_2_bfAtoDcr2], ADCINCVR_2_fAutoZero       ; Put the Integrator into Autozero mode
                                        (0262) ENDIF
06DD: 43 87 10 OR    REG[0x87],0x10     (0263)    or    reg[ADCINCVR_2_bfAtoDcr3], ADCINCVR_2_fFSW0           ; Put Integrator into reset
06E0: 41 E1 7F AND   REG[0xE1],0x7F     (0264)    and   reg[ADCINCVR_2_bfPWM16_INT_REG], ~ADCINCVR_2_bfPWM16_Mask      ; Disable interrupts
06E3: 41 E1 F7 AND   REG[0xE1],0xF7     (0265)    and   reg[ADCINCVR_2_bfCounter_INT_REG], ~ADCINCVR_2_bfCounter_Mask
                                        (0266) 
                                        (0267) ADCINCVR_2_END_PWM16_ISR:
06E6: 7E       RETI                     (0268)    reti
(0269) 
(0270) ; End of File ADCINCVR_2INT.asm
FILE: lib\adcincvr_1int.asm
                                        (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME:   ADCINCVR_1INT.asm
                                        (0004) ;;  Version: 3.1, Updated on 2009/10/15 at 17:11:37
                                        (0005) ;;  Generated by PSoC Designer 5.0.1127.0
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: ADCINCVR Interrupt Service Routines
                                        (0008) ;;-----------------------------------------------------------------------------
                                        (0009) ;;  Copyright (c) Cypress Semiconductor 2009. All Rights Reserved.
                                        (0010) ;;*****************************************************************************
                                        (0011) ;;*****************************************************************************
                                        (0012) 
                                        (0013) include "m8c.inc"
                                        (0014) include "memory.inc"
                                        (0015) include "ADCINCVR_1.inc"
                                        (0016) 
                                        (0017) ;-----------------------------------------------
                                        (0018) ;  Global Symbols
                                        (0019) ;-----------------------------------------------
                                        (0020) export _ADCINCVR_1_CNT_ISR
                                        (0021) export _ADCINCVR_1_PWM16_ISR
                                        (0022) export  ADCINCVR_1_cCounterU
                                        (0023) export _ADCINCVR_1_iResult
                                        (0024) export  ADCINCVR_1_iResult
                                        (0025) export _ADCINCVR_1_bfStatus
                                        (0026) export  ADCINCVR_1_bfStatus
                                        (0027) export  ADCINCVR_1_bSampC
                                        (0028) 
                                        (0029) ;-----------------------------------------------
                                        (0030) ; Variable Allocation
                                        (0031) ;-----------------------------------------------
                                        (0032) AREA InterruptRAM(RAM, REL, CON)
                                        (0033) 
                                        (0034)  ADCINCVR_1_cCounterU:     BLK   1  ;The Upper byte of the Counter
                                        (0035) _ADCINCVR_1_iResult:
                                        (0036)  ADCINCVR_1_iResult:       BLK   2  ;A/D value
                                        (0037) _ADCINCVR_1_bfStatus:
                                        (0038)  ADCINCVR_1_bfStatus:      BLK   1  ;Data Valid Flag
                                        (0039)  ADCINCVR_1_bSampC:        BLK   1  ;# of times to run A/D
                                        (0040) 
                                        (0041) 
                                        (0042) ;-----------------------------------------------
                                        (0043) ;  EQUATES and TABLES
                                        (0044) ;-----------------------------------------------
                                        (0045) LowByte:   equ 1
                                        (0046) HighByte:  equ 0
                                        (0047) 
                                        (0048) 
                                        (0049) ;@PSoC_UserCode_INIT@ (Do not change this line.)
                                        (0050) ;---------------------------------------------------
                                        (0051) ; Insert your custom declarations below this banner
                                        (0052) ;---------------------------------------------------
                                        (0053) 
                                        (0054) ;------------------------
                                        (0055) ; Includes
                                        (0056) ;------------------------
                                        (0057) 
                                        (0058) 	
                                        (0059) ;------------------------
                                        (0060) ;  Constant Definitions
                                        (0061) ;------------------------
                                        (0062) 
                                        (0063) 
                                        (0064) ;------------------------
                                        (0065) ; Variable Allocation
                                        (0066) ;------------------------
                                        (0067) 
                                        (0068) 
                                        (0069) ;---------------------------------------------------
                                        (0070) ; Insert your custom declarations above this banner
                                        (0071) ;---------------------------------------------------
                                        (0072) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0073) 
                                        (0074) AREA UserModules (ROM, REL)
                                        (0075) 
                                        (0076) .LITERAL
                                        (0077) ADCINCVR_1MaxNegX4Table:
                                        (0078) ; Bits  7    8    9   10   11   12   13
                                        (0079)    DB  FFh, FEh, FCh, F8h, F0h, E0h, C0h
                                        (0080) 
                                        (0081) ADCINCVR_1MaxPosX4Table:
                                        (0082) IF (ADCINCVR_1_DATA_FORMAT)
                                        (0083) ; Bits (signed)    7    8    9   10   11   12   13
                                        (0084)               DB  01h, 02h, 04h, 08h, 10h, 20h, 40h
                                        (0085) ELSE
                                        (0086) ; Bits (unsigned)  7    8    9   10   11   12   13
                                        (0087)               DB  02h, 04h, 08h, 10h, 20h, 40h, 80h
                                        (0088) 
                                        (0089)  ENDIF
                                        (0090) .ENDLITERAL
                                        (0091) 
                                        (0092) ;-----------------------------------------------------------------------------
                                        (0093) ;  FUNCTION NAME: _ADCINCVR_1_CNT_ISR (Counter8 Interrupt)
                                        (0094) ;
                                        (0095) ;
                                        (0096) ;  DESCRIPTION:
                                        (0097) ;     Increment the upper (software) half on the counter whenever the
                                        (0098) ;     lower (hardware) half of the counter underflows.  This counter
                                        (0099) ;     should start out at the most negative value (0xFF).
                                        (0100) ;
                                        (0101) ;-----------------------------------------------------------------------------
                                        (0102) ;
                                        (0103) _ADCINCVR_1_CNT_ISR:

(0104)    inc [ADCINCVR_1_cCounterU]
                                        (0105)    ;@PSoC_UserCode_BODY_1@ (Do not change this line.)
                                        (0106)    ;---------------------------------------------------
                                        (0107)    ; Insert your custom code below this banner
                                        (0108)    ;---------------------------------------------------
                                        (0109)    ;   NOTE: interrupt service routines must preserve
                                        (0110)    ;   the values of the A and X CPU registers.
                                        (0111) 
                                        (0112)    ;---------------------------------------------------
                                        (0113)    ; Insert your custom code above this banner
                                        (0114)    ;---------------------------------------------------
                                        (0115)    ;@PSoC_UserCode_END@ (Do not change this line.)
06F6: 17 7E 41 SUB   [X+126],0x41       (0116)    reti
                                        (0117) 
                                        (0118) 
                                        (0119) ;-----------------------------------------------------------------------------
                                        (0120) ;  FUNCTION NAME: _ADCINCVR_1_PWM16_ISR  (PWM16 Interrupt)
                                        (0121) ;
                                        (0122) ;  DESCRIPTION:
                                        (0123) ;     This ISR is called when the ADC has completed and integrate cycle.
                                        (0124) ;     The ADC value is calculated and stored in a global location before
                                        (0125) ;     the end of the ISR.
                                        (0126) ;
                                        (0127) ;-----------------------------------------------------------------------------
                                        (0128) ;
                                        (0129) _ADCINCVR_1_PWM16_ISR:
(0130)    and   reg[ADCINCVR_1_bCounter_CR0], ~ADCINCVR_1_fDBLK_ENABLE  ; Disable Counter
                                        (0131) IF ADCINCVR_1_NoAZ
06F9: 23 FE    AND   A,[X-2]            
06FB: 43 82 20 OR    REG[0x82],0x20     (0132)    or    reg[ADCINCVR_1_bfAtoDcr2], ADCINCVR_1_fAutoZero      ; Put Integrator in AutoZero
                                        (0133) ENDIF
06FE: 43 83 10 OR    REG[0x83],0x10     (0134)    or   reg[ADCINCVR_1_bfAtoDcr3],ADCINCVR_1_fFSW0         ; Put Integrator in reset
                                        (0135) 
                                        (0136)                                                            ; Enable interrupts for a short period of time just in case.
                                        (0137)                                                            ; Make sure we didn't have a counter interrupt ready to fire
0701: 71 01    OR    F,0x1              (0138)    M8C_EnableGInt
0703: 40       NOP                      (0139)    nop                                                     ; Wait a couple cycles
0704: 70 FE    AND   F,0xFE             (0140)    M8C_DisableGInt                                         ; Disable interrupt, read to complete processing
0706: 08       PUSH  A                  (0141)    push  A                                                 ; Save the Accumulator
0707: 5D 20    MOV   A,REG[0x20]        (0142)    mov   A,reg[ADCINCVR_1_bCount]                          ; Read counter value  (Bogus read puts value in Period register)
0709: 5D 22    MOV   A,REG[0x22]        (0143)    mov   A,reg[ADCINCVR_1_bCompare]                        ; Read counter value
070B: 78       DEC   A                  (0144)    dec   A                                                 ; Decrement by one to make sure we didn't miss a count
070C: 73       CPL   A                  (0145)    cpl   A                                                 ; Invert the value
070D: D0 03    JNC   0x0711             (0146)    jnc   ADCINCVR_1_INT_CALCV                              ; if carry, then inc MSB as well
070F: 76 17    INC   [iles+8]           (0147)    inc   [ADCINCVR_1_cCounterU]
                                        (0148) ADCINCVR_1_INT_CALCV:
0711: 53 19    MOV   [iles+10],A        (0149)    mov   [(ADCINCVR_1_iResult + LowByte)], A               ; Store LSB value
0713: 51 17    MOV   A,[iles+8]         (0150)    mov   A, [ADCINCVR_1_cCounterU]                         ; Store MSB from temp counter
0715: 53 18    MOV   [iles+9],A         (0151)    mov   [(ADCINCVR_1_iResult + HighByte)], A
                                        (0152)                                                            ; The new value has been stored,
                                        (0153)                                                            ; so get counters ready for next reading first.
0717: 62 21 FF MOV   REG[0x21],0xFF     (0154)    mov   reg[ADCINCVR_1_bPeriod], ffh                      ; Initialize counter to FF - Set to overflow after 256 counts
071A: 43 23 01 OR    REG[0x23],0x1      (0155)    or    reg[ADCINCVR_1_bCounter_CR0],ADCINCVR_1_fDBLK_ENABLE  ; Enable Counter
                                        (0156) 
                                        (0157) IF (ADCINCVR_1_DATA_FORMAT)                                ; Only check for Negative numbers if SIGNED result
                                        (0158)    mov   A, [ADCINCVR_1_bfStatus]                          ; Get Status with Resolution
                                        (0159)    and   A, ADCINCVR_1_bRES_MASK                           ; Mask of resolution
                                        (0160)    index ADCINCVR_1MaxNegX4Table                           ; Get Maximum negative value from table
                                        (0161)    mov   [ADCINCVR_1_cCounterU], A                         ; Place result back into MSB of counter
                                        (0162) ELSE
071D: 55 17 00 MOV   [iles+8],0x0       (0163)    mov   [ADCINCVR_1_cCounterU], 00h                       ; Place result back into MSB of counter
                                        (0164) ENDIF
                                        (0165) 
                                        (0166)    ;@PSoC_UserCode_BODY_2@ (Do not change this line.)
                                        (0167)    ;---------------------------------------------------
                                        (0168)    ; If the input is muxed with multiple inputs
                                        (0169)    ; this is a good place to change inputs.
                                        (0170)    ; Insert your custom code below this banner
                                        (0171)    ;---------------------------------------------------
                                        (0172)    ;   NOTE: interrupt service routines must preserve
                                        (0173)    ;   the values of the A and X CPU registers. At this
                                        (0174)    ;   point A is already preserved and will be restored;
                                        (0175)    ;   however, if you use X, you must take care of it
                                        (0176)    ;   here!
                                        (0177) 
                                        (0178)    ;---------------------------------------------------
                                        (0179)    ; Insert your custom code above this banner
                                        (0180)    ;---------------------------------------------------
                                        (0181)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0182) 
0720: 41 83 EF AND   REG[0x83],0xEF     (0183)    and   reg[ADCINCVR_1_bfAtoDcr3],~ADCINCVR_1_fFSW0       ; Take Integrator out of reset
                                        (0184) IF ADCINCVR_1_NoAZ
0723: 41 82 DF AND   REG[0x82],0xDF     (0185)    and   reg[ADCINCVR_1_bfAtoDcr2],~ADCINCVR_1_fAutoZero   ; Take Integrator out of AutoZero
                                        (0186) ENDIF
                                        (0187) 
                                        (0188)    ;****************************************************************************
                                        (0189)    ;M8C_EnableGInt            ; May want to re-enable interrupts at this point,
                                        (0190)    ;                          ; if stack space isn't at a premium.
                                        (0191)    ; NOTE:  this will make system more responsive but, will increase the
                                        (0192)    ;        overall processing time of the A/D calctime.  If an interrupt is
                                        (0193)    ;        taken, it must return within the specified CalcTime to guarantee
                                        (0194)    ;        successful acquisition of the next byte.
                                        (0195)    ;****************************************************************************
                                        (0196) IF (ADCINCVR_1_DATA_FORMAT)                      ; Only check for Negative numbers if SIGNED result
                                        (0197) 
                                        (0198)                                                  ; Negative Overflow Check
                                        (0199)    tst   [(ADCINCVR_1_iResult + HighByte)],80h
                                        (0200)    jnz   ADCINCVR_1_NOT_POVFL2
                                        (0201) 
                                        (0202) ENDIF
                                        (0203)                                                  ; Postive Overflow Check
                                        (0204)                                                  ; Get MSB of Max Positive value x4 + 1
0726: 51 1A    MOV   A,[iles+11]        (0205)    mov   A,[ADCINCVR_1_bfStatus]                 ; Get Status with Resolution
0728: 21 0F    AND   A,0xF              (0206)    and   A,ADCINCVR_1_bRES_MASK                  ; Mask of resolution normalized to 0
072A: FF C2    INDEX 0x06EE             (0207)    index ADCINCVR_1MaxPosX4Table                 ; Get Maximum positive value x4 + 1 from table
072C: 08       PUSH  A                  (0208)    push  A
072D: 22 18    AND   A,[iles+9]         (0209)    and   A, [(ADCINCVR_1_iResult + HighByte)]
072F: A0 0B    JZ    0x073B             (0210)    jz    ADCINCVR_1_NOT_POVFL
                                        (0211)                                                  ; Positive overflow, fix it - set to Max Positive + 1
0731: 18       POP   A                  (0212)    pop   A
0732: 11 01    SUB   A,0x1              (0213)    sub   A, 01h
                                        (0214) 
                                        (0215)                                                  ; Force most positive * 4 into result
0734: 53 18    MOV   [iles+9],A         (0216)    mov   [(ADCINCVR_1_iResult + HighByte)], A
0736: 55 19 FF MOV   [iles+10],0xFF     (0217)    mov   [(ADCINCVR_1_iResult + LowByte)], ffh
0739: 80 02    JMP   0x073C             (0218)    jmp   ADCINCVR_1_NOT_POVFL2
                                        (0219) ADCINCVR_1_NOT_POVFL:
073B: 18       POP   A                  (0220)    pop   A
                                        (0221) 
                                        (0222) ADCINCVR_1_NOT_POVFL2:
073C: 68 18    ASR   [iles+9]           (0223)    asr   [(ADCINCVR_1_iResult + HighByte)]       ; Shift MSB and LSB right twice to divide by four
073E: 6E 19    RRC   [iles+10]          (0224)    rrc   [(ADCINCVR_1_iResult + LowByte)]        ; Remember digital clock 4 times analog clock
0740: 68 18    ASR   [iles+9]           (0225)    asr   [(ADCINCVR_1_iResult + HighByte)]
0742: 6E 19    RRC   [iles+10]          (0226)    rrc   [(ADCINCVR_1_iResult + LowByte)]
                                        (0227) 
                                        (0228)    ;@PSoC_UserCode_BODY_3@ (Do not change this line.)
                                        (0229)    ;---------------------------------------------------
                                        (0230)    ; Data is ready at this point.
                                        (0231)    ; If processing Data at Interrupt level - add
                                        (0232)    ; User Code to handle the data below this banner
                                        (0233)    ;---------------------------------------------------
                                        (0234)    ;   NOTE: interrupt service routines must preserve
                                        (0235)    ;   the values of the A and X CPU registers. At this
                                        (0236)    ;   point A is already preserved and will be restored;
                                        (0237)    ;   however, if you use X, you must take care of it
                                        (0238)    ;   here!
                                        (0239) 
                                        (0240)    ;---------------------------------------------------
                                        (0241)    ; Insert your custom code above this banner
                                        (0242)    ;---------------------------------------------------
                                        (0243)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0244) 
0744: 18       POP   A                  (0245)    pop   A                                       ; Restore A, not used any more
                                        (0246) 
0745: 2E 1A 10 OR    [iles+11],0x10     (0247)    or    [ADCINCVR_1_bfStatus],ADCINCVR_1_fDATA_READY  ; Set Data ready bit
                                        (0248) 
0748: 47 1B FF TST   [iles+12],0xFF     (0249)    tst   [ADCINCVR_1_bSampC], ffh                ; If sample_counter == 0 -->> continuous data collection
074B: A0 17    JZ    0x0763             (0250)    jz    ADCINCVR_1_END_PWM16_ISR
                                        (0251) 
074D: 7A 1B    DEC   [iles+12]          (0252)    dec   [ADCINCVR_1_bSampC]                     ; Dec sample counter and check for zero
074F: B0 13    JNZ   0x0763             (0253)    jnz   ADCINCVR_1_END_PWM16_ISR
                                        (0254) 
                                        (0255)    ;**********************************************
                                        (0256)    ; Turn off ADC
                                        (0257)    ;**********************************************
0751: 41 27 FE AND   REG[0x27],0xFE     (0258)    and   reg[ADCINCVR_1_fPWM_LSB_CR0], ~ADCINCVR_1_fDBLK_ENABLE     ; Disable the PWM
0754: 41 23 FE AND   REG[0x23],0xFE     (0259)    and   reg[ADCINCVR_1_bCounter_CR0], ~ADCINCVR_1_fDBLK_ENABLE           ; Disable the Counter
                                        (0260) IF ADCINCVR_1_NoAZ
0757: 43 82 20 OR    REG[0x82],0x20     (0261)    or    reg[ADCINCVR_1_bfAtoDcr2], ADCINCVR_1_fAutoZero       ; Put the Integrator into Autozero mode
                                        (0262) ENDIF
075A: 43 83 10 OR    REG[0x83],0x10     (0263)    or    reg[ADCINCVR_1_bfAtoDcr3], ADCINCVR_1_fFSW0           ; Put Integrator into reset
075D: 41 E1 FB AND   REG[0xE1],0xFB     (0264)    and   reg[ADCINCVR_1_bfPWM16_INT_REG], ~ADCINCVR_1_bfPWM16_Mask      ; Disable interrupts
0760: 41 E1 FE AND   REG[0xE1],0xFE     (0265)    and   reg[ADCINCVR_1_bfCounter_INT_REG], ~ADCINCVR_1_bfCounter_Mask
                                        (0266) 
                                        (0267) ADCINCVR_1_END_PWM16_ISR:
0763: 7E       RETI                     (0268)    reti
(0269) 
(0270) ; End of File ADCINCVR_1INT.asm
FILE: C:\projects\box\BOX_SL~1\BOX_SL~1\BOX_SL~1\main.c
(0001) // box
(0002) // CY8C29466
(0003) 
(0004) #include <m8c.h>        // part specific constants and macros
(0005) #include "PSoCAPI.h"    // PSoC API definitions for all User Modules
(0006) 
(0007) #define _BV(BIT) (1<<BIT)
(0008) #define sbi(BYTE,BIT) (BYTE |= _BV(BIT))
(0009) #define cbi(BYTE,BIT) (BYTE &= ~_BV(BIT))
(0010) 
(0011) #define LED_ON() sbi(PRT2DR, 0) // LED
(0012) #define LED_OFF() cbi(PRT2DR, 0)
(0013) #define BTN_PORT PRT2DR // push button
(0014) #define BTN_BIT _BV(2)
(0015) 
(0016) 
(0017) void main(void)
_main|__text_start|_main:
    0764: 43 08 01 OR    REG[0x8],0x1
(0018) {
(0019)     LED_ON();
(0020)     for(;;){
(0021)         
(0022)     }
    0767: 8F FF    JMP   0x0767
(0023) }
FILE: lib\psocgpioint.asm
                                        (0001) ; Generated by PSoC Designer 5.0.1127.0
                                        (0002) ;
                                        (0003) ;;*****************************************************************************
                                        (0004) ;;*****************************************************************************
                                        (0005) ;;  FILENAME: PSoCGPIOINT.asm
                                        (0006) ;;   Version: 2.0.0.20, Updated on 2003/07/17 at 12:10:35
                                        (0007) ;;  @PSOC_VERSION
                                        (0008) ;;
                                        (0009) ;;  DESCRIPTION: PSoC GPIO Interrupt Service Routine
                                        (0010) ;;-----------------------------------------------------------------------------
                                        (0011) ;;  Copyright (c) Cypress Semiconductor 2009. All Rights Reserved.
                                        (0012) ;;*****************************************************************************
                                        (0013) ;;*****************************************************************************
                                        (0014) 
                                        (0015) include "m8c.inc"
                                        (0016) include "PSoCGPIOINT.inc"
                                        (0017) 
                                        (0018) ;-----------------------------------------------
                                        (0019) ;  Global Symbols
                                        (0020) ;-----------------------------------------------
                                        (0021) export   PSoC_GPIO_ISR
                                        (0022) 
                                        (0023) 
                                        (0024) ;-----------------------------------------------
                                        (0025) ;  Constant Definitions
                                        (0026) ;-----------------------------------------------
                                        (0027) 
                                        (0028) 
                                        (0029) ;-----------------------------------------------
                                        (0030) ; Variable Allocation
                                        (0031) ;-----------------------------------------------
                                        (0032) 	
                                        (0033) 
                                        (0034) ;@PSoC_UserCode_INIT@ (Do not change this line.)
                                        (0035) ;---------------------------------------------------
                                        (0036) ; Insert your custom declarations below this banner
                                        (0037) ;---------------------------------------------------
                                        (0038) 
                                        (0039) ;---------------------------------------------------
                                        (0040) ; Insert your custom declarations above this banner
                                        (0041) ;---------------------------------------------------
                                        (0042) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0043) 
                                        (0044) 
                                        (0045) ;-----------------------------------------------------------------------------
                                        (0046) ;  FUNCTION NAME: PSoC_GPIO_ISR
                                        (0047) ;
                                        (0048) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
                                        (0049) ;
                                        (0050) ;-----------------------------------------------------------------------------
                                        (0051) ;
                                        (0052) PSoC_GPIO_ISR:
                                        (0053) 
                                        (0054) 
                                        (0055)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                        (0056)    ;---------------------------------------------------
                                        (0057)    ; Insert your custom code below this banner
                                        (0058)    ;---------------------------------------------------
                                        (0059) 
                                        (0060)    ;---------------------------------------------------
                                        (0061)    ; Insert your custom code above this banner
                                        (0062)    ;---------------------------------------------------
                                        (0063)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0064) 

076B: 7E       RETI                     (0065)    reti
(0066) 
(0067) 
(0068) ; end of file PSoCGPIOINT.asm
FILE: <library>
--------------------------------------------------------------------------------


PSoC Designer Version: 5.0.1127.0

Copyright (C) 1994 - 2009 ImageCraft Creations Inc.
ImageCraft, 706 Colorado Ave., Suite 10-88, Palo Alto, CA 94303
info@imagecraft.com, phone (650) 493-9326 FAX (650) 493-9329
http://www.imagecraft.com
lcc source code (C) 1995, by David R. Hanson and AT&T. Reproduced by permission.
Release version 7.02.004
